<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EmberJS.CN Blog</title>
  <subtitle>Ember JS相关新闻与资源</subtitle>
  <id>http://emberjs.cn/blog</id>
  <link href="http://emberjs.cn/blog"/>
  <link href="http://emberjs.cn/blog/feed.xml" rel="self"/>
  <updated>2013-08-28T00:00:00Z</updated>
  <author>
    <name>EmberJS.CN</name>
  </author>
  <entry>
    <title>Ember 1.0 RC8发布</title>
    <link rel="alternate" href="/blog/2013/08/28/ember-1-0-rc8.html"/>
    <id>/blog/2013/08/28/ember-1-0-rc8.html</id>
    <published>2013-08-28T00:00:00Z</published>
    <updated>2013-08-28T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;Ember 1.0 RC8是1.0正式版前的最后一次发布，如果一切顺利本周末将发布Ember
1.0正式版。&lt;/p&gt;

&lt;p&gt;在RC8中做了一些1.0正式版之前的重大更改，这些更改对应用代码只有很少的影响，不过带来了很大的性能提升。&lt;/p&gt;

&lt;p&gt;这些更改都与观察器有关。如果编码的时候使用了大量的观察器，那么可能意味着代码不符合语言习惯。通常只在与其他不支持绑定机制的库桥接的时候需要使用观察器。&lt;/p&gt;

&lt;p&gt;例如，如果编写一个包裹jQuery
UI控件的组件时，可能需要使用观察器来监视组件上的改变，并将这些改变反映到控件上。&lt;/p&gt;

&lt;p&gt;在应用代码中，应该尽可能的使用计算属性。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;Ember 1.0 RC8是1.0正式版前的最后一次发布，如果一切顺利本周末将发布Ember
1.0正式版。&lt;/p&gt;

&lt;p&gt;在RC8中做了一些1.0正式版之前的重大更改，这些更改对应用代码只有很少的影响，不过带来了很大的性能提升。&lt;/p&gt;

&lt;p&gt;这些更改都与观察器有关。如果编码的时候使用了大量的观察器，那么可能意味着代码不符合语言习惯。通常只在与其他不支持绑定机制的库桥接的时候需要使用观察器。&lt;/p&gt;

&lt;p&gt;例如，如果编写一个包裹jQuery
UI控件的组件时，可能需要使用观察器来监视组件上的改变，并将这些改变反映到控件上。&lt;/p&gt;

&lt;p&gt;在应用代码中，应该尽可能的使用计算属性。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;声明事件监听器&lt;/h4&gt;
&lt;p&gt;现在Ember提供了一种方法来用声明的方式给Ember类添加事件监听器。这比手动在&lt;code&gt;init&lt;/code&gt;中设置监听器要简单很多。&lt;/p&gt;

&lt;p&gt;以前的方法：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = DS.Model.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;didLoad&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="local-variable"&gt;this&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;() {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.finishedLoading();
    });
  },

  &lt;span class="function"&gt;finishedLoading&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// do stuff&lt;/span&gt;
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在只需要：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = DS.Model.extend({
  &lt;span class="function"&gt;finishedLoading&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// do stuff&lt;/span&gt;
  }.on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;didLoad&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;数组计算&lt;/h4&gt;
&lt;p&gt;现在有一种符合惯例和稳定的方法来构建一个基于数组的计算属性，其将只对更新的部分进行计算。&lt;/p&gt;

&lt;p&gt;例如，当有一组people时，并想通过一个计算属性返回他们的年龄。&lt;/p&gt;

&lt;p&gt;当前最简单的实现方法是：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;childAges&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).mapProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children.@each.age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样实现非常简洁，但是当数组中任何时候有一个元素被添加或者删除时，就会重新计算整个数组。对于小的数组来说，这可能不成问题。然而，如果数组非常巨大，或者这些计算属性被链式使用，或者用于完成一些繁重的工作，那么开销将会非常大。&lt;/p&gt;

&lt;p&gt;这时可以使用数组计算属性性：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;childAges&lt;/span&gt;: Ember.computed.mapProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以将数组计算属性链接在一起：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;childAges&lt;/span&gt;: Ember.computed.mapProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),
  &lt;span class="key"&gt;maxChildAge&lt;/span&gt;: Ember.computed.max(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;childAges&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当一个元素被添加或者删除时，计算只进行一次。在本例中，如果添加一个孩子，那他的年龄会被追加到&lt;code&gt;childAges&lt;/code&gt;中，并且如果这个年龄大于&lt;code&gt;maxChildAge&lt;/code&gt;，那么&lt;code&gt;maxChildAge&lt;/code&gt;也将得到更新。&lt;/p&gt;

&lt;p&gt;这些计算属性总是保持同步、高效，并完全由Ember来管理。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_ember'&gt;Ember扩展&lt;/h4&gt;
&lt;p&gt;经过几个月的测试，及Teddy Zeenny的辛勤付出，Ember
Inspector已经准备发布到Chrome Web Store了。&lt;/p&gt;

&lt;p&gt;最近，Teddy添加了对加载的数据的支持。已经支持Ember Data，Ember
Model的支持也在开发中。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-ember-data.png"&gt;&lt;/p&gt;

&lt;p&gt;Teddy完成了对象检查器的重大改进，增加了对组属性对象的支持（如：Ember
Data模型的属性、一对多关联），支持通过检查器修改对象。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-editing.png"&gt;&lt;/p&gt;

&lt;p&gt;通过检查器可以查看应用中所有路由的列表，这些命名可以与对象结合使用。这样更容易记住命名惯例。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-routes.png"&gt;&lt;/p&gt;

&lt;p&gt;另外，视图树通过应用模板关联的控制器和模型显示了应用的概况。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-view-tree.png"&gt;&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;其他改进&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;改进&lt;code&gt;yield&lt;/code&gt;，确保其总是&lt;code&gt;yield&lt;/code&gt;回调用的上下文。&lt;/li&gt;
&lt;li&gt;不使用W3C range API来改进range更新的性能&lt;/li&gt;
&lt;li&gt;完成1.0文档的审查&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;重复定义同名的模板时给出更加友好的错误消息&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;ApplicationController&lt;/code&gt;中添加&lt;code&gt;currentRouteName&lt;/code&gt;，可以用于&lt;code&gt;link-to&lt;/code&gt;和&lt;code&gt;transitionTo&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;定义新的别名：&lt;code&gt;linkTo&lt;/code&gt; -&amp;gt; &lt;code&gt;link-to&lt;/code&gt;，&lt;code&gt;bindAttr&lt;/code&gt; -&amp;gt; &lt;code&gt;bind-attr&lt;/code&gt;，来保持与html命名一致。老命名还保留不过已经软废除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_tl-dr'&gt;更新 TL;DR&lt;/h4&gt;&lt;h5 class='anchorable-toc' id='toc_'&gt;观察器在构造过程中不触发&lt;/h5&gt;
&lt;p&gt;以前通过&lt;code&gt;create&lt;/code&gt;传入或者在prototype上指定的属性不会触发观察器，但在&lt;code&gt;init&lt;/code&gt;中通过&lt;code&gt;set&lt;/code&gt;方法设置的属性会触发。&lt;/p&gt;

&lt;p&gt;现在观察器直到&lt;code&gt;init&lt;/code&gt;完后才会触发观察器。&lt;/p&gt;

&lt;p&gt;如果在初始化过程中需要出发一个观察器，不能通过&lt;code&gt;set&lt;/code&gt;来实现，需要在观察器上通过&lt;code&gt;.on(&amp;#39;init&amp;#39;)&lt;/code&gt;指定其在&lt;code&gt;init&lt;/code&gt;下也工作。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;salutation&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Mr/Ms&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
  },

  &lt;span class="function"&gt;salutationDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// some side effect of salutation changing&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;salutation&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;init&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h5 class='anchorable-toc' id='toc_'&gt;没有消费的计算属性不触发观察器&lt;/h5&gt;
&lt;p&gt;如果从未&lt;code&gt;get&lt;/code&gt;一个计算属性，与它相关的观察器不会被触发，即使其依赖的键已经改变。可以想象为值从一个未知的值变成了另一个。&lt;/p&gt;

&lt;p&gt;这基本上不会影响到应用程序代码，因为计算属性几乎总是在其取来的时候同时被观察到。例如，获取一个计算属性的值，将其放置到DOM中，（或者通过D3绘图），接着观察它，以便在其更新的时候更新DOM。&lt;/p&gt;

&lt;p&gt;如果需要观察一个不需要立即使用的计算属性，可以在&lt;code&gt;init&lt;/code&gt;方法中&lt;code&gt;get&lt;/code&gt;它一下。&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_'&gt;路由、控制器和视图的新操作哈希&lt;/h5&gt;
&lt;p&gt;为了保持一致性并提供更灵活的操作命名，通过一个统一的&lt;code&gt;actions&lt;/code&gt;哈希来定义操作。当继承一个定义了&lt;code&gt;actions&lt;/code&gt;的类时，会在子类将定义的&lt;code&gt;actions&lt;/code&gt;进行合并，或在父进行实例化。另外还支持&lt;code&gt;_super&lt;/code&gt;，因此没有散失任何的灵活性。&lt;/p&gt;

&lt;p&gt;之前的行为依然支持，不过已经废除了。如果一个控制器代理了一个拥有&lt;code&gt;actions&lt;/code&gt;属性的模型，那么将自动将其重命名为&lt;code&gt;_actions&lt;/code&gt;来避免发生任何可能的冲突。&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_handlebars'&gt;在Handlebars助手中使用引号引起来的字符串&lt;/h5&gt;
&lt;p&gt;过去，Handlebars助手没有严格限制字符串是否需要加引号。不幸的是，这意味着没有办法区分字符串值和属性路径。现在严格限制如果希望是一个字符串值的话，必须加引号。这意味着&lt;code&gt;link-to&lt;/code&gt;的路由名必须用引号引起来。相反，如果定义一个自定义的绑定助手，并且用一个引号引起来的字符表示属性路径，这将不再工作。加引号表示字符串，不加表示路径。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_code-init-code'&gt;在&lt;code&gt;init&lt;/code&gt;中设置属性&lt;/h4&gt;
&lt;p&gt;当前，传递一个哈希给&lt;code&gt;create&lt;/code&gt;和在&lt;code&gt;init&lt;/code&gt;中设置同样的属性是不一致的。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// this observer does not fire&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});

App.Person.create({ &lt;span class="key"&gt;firstName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tom&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Dale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;本例中，由于所有属性都是通过一个传给&lt;code&gt;create&lt;/code&gt;的hash来设置的，观察器不会被触发。&lt;/p&gt;

&lt;p&gt;下面看一看在RC7中在&lt;code&gt;init&lt;/code&gt;方法里完成同样的出发会发生什么：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR&lt;/span&gt;

App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;if&lt;/span&gt; (!&lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)) {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tom&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
    }
  },
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// this observer fires&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});

App.Person.create({ &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Dale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在此，如果&lt;code&gt;firstName&lt;/code&gt;没有，也会出发观察器。&lt;/p&gt;

&lt;p&gt;新的设计对象模型只在构造后会触发观察器，这是为什么&lt;code&gt;create&lt;/code&gt;不触发的原因。&lt;/p&gt;

&lt;p&gt;此外，因为如果为包含数组、对象值的属性进行初始化只能在&lt;code&gt;init&lt;/code&gt;中，这导致了不一致性：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR&lt;/span&gt;

App.Person = Ember.Object.extend({
  &lt;span class="comment"&gt;// initial property value, does not trigger an initialization observer&lt;/span&gt;
  &lt;span class="key"&gt;salutation&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Mr.&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,

  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// also initial property value, triggers an observer on&lt;/span&gt;
    &lt;span class="comment"&gt;// initialization&lt;/span&gt;
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, []);
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;总之，属性在初始化过程中被设置不论是否设置到prototype，或作为哈希传给&lt;code&gt;create&lt;/code&gt;，或在&lt;code&gt;init&lt;/code&gt;中被设置，都不触发观察器。&lt;/p&gt;

&lt;p&gt;如果有代码需要不论是在初始化过程还是当一个属性改变时执行，必须使用&lt;code&gt;.on(&amp;#39;init&amp;#39;)&lt;/code&gt;将其标记为需要在初始化过程执行。这种情况最好是进行重构，来避免&lt;code&gt;init&lt;/code&gt;时&lt;code&gt;set&lt;/code&gt;的负面效应。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// some side effect that happens when first name changes&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;init&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;计算属性性能改进&lt;/h4&gt;
&lt;p&gt;最新发布的Ember.js版本包含了观察器和计算属性交互的更新。这对依赖旧有行为的应用是一个破坏性的更新。&lt;/p&gt;

&lt;p&gt;为了理解这个更新，通过一个计算属性的例子来介绍。假设尝试用Ember.js对象来为&lt;a href="http://en.wikipedia.org/wiki/Schr%C3%B6dinger&amp;#x27;s_cat"&gt;Schrödinger&amp;#39;s famous cat&lt;/a&gt; 建模。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Cat = Ember.Object.extend({
  &lt;span class="function"&gt;isDead&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; Math.rand() &amp;gt; &lt;span class="float"&gt;0.5&lt;/span&gt;;
  }.property()
});

&lt;span class="keyword"&gt;var&lt;/span&gt; cat = App.Cat.create();
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;给定一个猫的对象，判断猫是死是活？这里通过一个随机数来决定。在观察猫对象之前，可以说猫既是死的又是活的，或者要死不活。&lt;/p&gt;

&lt;p&gt;而实际上，并非猫超凡脱俗，而是取决于第一次调用。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;cat.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;isDead&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class="comment"&gt;// true&lt;/span&gt;
&lt;span class="comment"&gt;// …or false, half the time&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在询问了猫对象的&lt;code&gt;isDead&lt;/code&gt;属性后，就可以明确的说猫是死还是活。但是在此之前，这个计算属性的值并不存在。&lt;/p&gt;

&lt;p&gt;下面看看在混合（Mix）中的观察器。如果计算属性的值还不存在，其依赖的键发生改变时是否触发观察器？&lt;/p&gt;

&lt;p&gt;在之前版本的Ember.js中，答案是肯定的。例如：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;observerCount&lt;/span&gt;: &lt;span class="integer"&gt;0&lt;/span&gt;,

  &lt;span class="function"&gt;fullName&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),

  &lt;span class="function"&gt;fullNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.incrementProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;依赖的任意键发生改变，都会触发观察者：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR DO NOT RELY ON THIS&lt;/span&gt;

&lt;span class="keyword"&gt;var&lt;/span&gt; person = App.Person.create({
  &lt;span class="key"&gt;firstName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Yehuda&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Katz&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
});

person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 0&lt;/span&gt;

person.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tomhuda&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 1&lt;/span&gt;

person.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Katzdale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后，因为&lt;code&gt;fullName&lt;/code&gt;属性并不&amp;quot;exist&amp;quot;直到请求它为止，触发一个观察者是否是正确的行为并不明确。&lt;/p&gt;

&lt;p&gt;一个影响计算属性的关联问题是如果计算属性依赖键包含一个路径。（请记住依赖键只是定义一个计算属性时，传递个&lt;code&gt;.property()&lt;/code&gt;方法的属性名。&lt;/p&gt;

&lt;p&gt;例如，假设构造一个模型表示一篇博客，如果需要使用博客的评论，采用延迟加载的方式加载评论（例如在模板中）。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.BlogPost = Ember.Object.extend({
  &lt;span class="function"&gt;comments&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;var&lt;/span&gt; comments = [];
    &lt;span class="keyword"&gt;var&lt;/span&gt; url = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/post/&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/comments.json&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);

    &lt;span class="predefined"&gt;$&lt;/span&gt;.getJSON(url) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/comments.json&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).then(&lt;span class="keyword"&gt;function&lt;/span&gt;(data) {
      data.forEach(&lt;span class="keyword"&gt;function&lt;/span&gt;(comment) {
        comments.pushObject(comment);
      });
    });

    &lt;span class="keyword"&gt;return&lt;/span&gt; comments;
  }.property()
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在这里跟预期的行为一样，博文的评论只会在第一次使用&lt;code&gt;post.get(&amp;#39;comments&amp;#39;)&lt;/code&gt;或者在模板中使用的时候，才通过网络去加载：&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt; &lt;span class="attribute-name"&gt;comments&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;title&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然而，现在希望添加一个计算属性，用来从加载的评论中选择第一条：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.BlogPost = Ember.Object.extend({
  &lt;span class="function"&gt;comments&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;var&lt;/span&gt; comments = [];
    &lt;span class="keyword"&gt;var&lt;/span&gt; url = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/post/&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/comments.json&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;

    &lt;span class="predefined"&gt;$&lt;/span&gt;.getJSON(url).then(&lt;span class="keyword"&gt;function&lt;/span&gt;(data) {
      data.forEach(&lt;span class="keyword"&gt;function&lt;/span&gt;(comment) {
        comments.pushObject(comment);
      });
    });

    &lt;span class="keyword"&gt;return&lt;/span&gt; comments;
  }.property(),

  &lt;span class="function"&gt;firstComment&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comments.firstObject&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comments.firstObject&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在有了一个问题！因为&lt;code&gt;firstComment&lt;/code&gt;计算属性依赖&lt;code&gt;comments.firstObject&lt;/code&gt;，为了建立一个&lt;code&gt;firstObject&lt;/code&gt;的观察器，它将&lt;code&gt;get()&lt;/code&gt;&lt;code&gt;comments&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;在此添加这个计算属性意味着应用中所有博文的评论都被加载，无论评论是否被使用！&lt;/p&gt;

&lt;p&gt;为了决定如何处理，花了一些时间分析实际的Ember.js应用。发现这个行为严重的影响了性能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;触发没有物化的计算属性的观察器意味着需要在一开始的时候为所有计算属性设置监听器，而不是在第一次计算的时候。&lt;/li&gt;
&lt;li&gt;许多计算属性因为路径依赖键，从未使用，也未被计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了修正这些问题，&lt;strong&gt;RC8做了一下改变&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;观察一个计算属性的观察器只在该属性被使用过至少一次后才会被触发。&lt;/li&gt;
&lt;li&gt;观察一个路径（&lt;code&gt;&amp;quot;foo.bar.baz&amp;quot;&lt;/code&gt;），或者使用一个路径作为一个依赖主键，将不导致路径任意部分从未计算变为计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大部分Ember.js应用程序不会受此影响，因为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;大部分应用程序观察计算属性，并且在对象初始化时就&lt;code&gt;get()&lt;/code&gt;这些属性，因而触发了正确的行为。&lt;/li&gt;
&lt;li&gt;对于计算属性依赖键，新行为正是开发者所期待的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果应用受这个更改的影响，修正方法非常简单，只需要在类的&lt;code&gt;init&lt;/code&gt;方法中&lt;code&gt;get()&lt;/code&gt;计算属性即可。&lt;/p&gt;

&lt;p&gt;例如，为了更新上述的观察器例子，能通过&amp;quot;precomputing&amp;quot;&lt;code&gt;fullName&lt;/code&gt;属性来保持RC8之前版本的行为：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
    &lt;span class="local-variable"&gt;this&lt;/span&gt;._super();
  },

  &lt;span class="key"&gt;observerCount&lt;/span&gt;: &lt;span class="integer"&gt;0&lt;/span&gt;,

  &lt;span class="function"&gt;fullName&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),

  &lt;span class="function"&gt;fullNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.incrementProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_code-link-to-code'&gt;&lt;code&gt;link-to&lt;/code&gt;绑定参数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;link-to&lt;/code&gt;助手（之前为&lt;code&gt;linkTo&lt;/code&gt;）现在将未加引号的参数（非数字参数）作为绑定属性路径对待，这意味着当一个传给&lt;code&gt;link-to&lt;/code&gt;的属性改变时，链接的&lt;code&gt;href&lt;/code&gt;将改变。这包括第一个参数（目标路由名）和接着的任意上下文参数。&lt;/p&gt;

&lt;p&gt;下面的模板例子将在当前上下文（通常是一个控制器）查找&lt;code&gt;destinationRoute&lt;/code&gt;，并使用其来决定链接的&lt;code&gt;href&lt;/code&gt;和点击链接将切换至的路由。&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt; &lt;span class="attribute-name"&gt;destinationRoute&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;Link Text&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面的例子将一直指向&lt;code&gt;articles.show&lt;/code&gt;路由（因为路由名称参数加了引号），但是当&lt;code&gt;article&lt;/code&gt;的值改变时，链接的&lt;code&gt;href&lt;/code&gt;将更新为对应&lt;code&gt;article&lt;/code&gt;新值的URL。&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt; &lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="attribute-name"&gt;articles.show&lt;/span&gt;&lt;span class="error"&gt;'&lt;/span&gt; &lt;span class="attribute-name"&gt;article&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;Read More...&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果之前写的应用没有正确的区分加引号的字符串和属性路径，这可能导致一些问题。因此当升级到RC8时，需要确定所有&lt;code&gt;link-to&lt;/code&gt;参数的静态字符串都正确的添加了引号。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;绑定助手：加引号的字符串，数字和路径&lt;/h4&gt;
&lt;p&gt;调用自定义的绑定助手（如通过&lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;定义的）时传入加引号的字符串或者原生数字会将其原值直接传入，而不是将所有的都作为绑定属性的路径，每次在属性变化的时候都重新渲染助手。&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Pass the string 'hello' to myHelper:
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;myHelper&lt;/span&gt; &lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="attribute-name"&gt;hello&lt;/span&gt;&lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;

Pass the property pointed-to by the path 'hello' to myHelper:
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;myHelper&lt;/span&gt; &lt;span class="attribute-name"&gt;hello&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果之前调用绑定助手时传入加引号的字符串，并期望其是一个绑定属性路径，那么会导致应用出现一些问题。因此需要确定只有当确实需要传入一个字符串的时候才给参数加引号，而不是路径对应的值。
如果之前写的应用没有正确的区分加引号的字符串和属性路径，这可能导致一些问题。因此当升级到RC8时，需要确定所有&lt;code&gt;link-to&lt;/code&gt;参数的静态字符串都正确的添加了引号。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember.js 1.0 RC7发布</title>
    <link rel="alternate" href="/blog/2013/08/14/ember-1-0-rc7.html"/>
    <id>/blog/2013/08/14/ember-1-0-rc7.html</id>
    <published>2013-08-14T00:00:00Z</published>
    <updated>2013-08-14T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;今天Ember.js 1.0 RC7发布了！如果一切顺利，这将是Ember 1.0的倒数第二个RC版本。RC7中修复了许多Bug，同时也包括了一些小的改进。另外还有一些Bug还在修正中，由于RC7已经逾期了，因此不等修正所有的Bug。下周将发布RC8，下面内容包含了本次发布做的一些修改。&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;重要改变&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_code-route-controllerfor-code'&gt;&lt;code&gt;Route#controllerFor&lt;/code&gt;不再自动生成控制器&lt;/h4&gt;
&lt;p&gt;有的时候，人们依赖&lt;code&gt;controllerFor&lt;/code&gt;来访问没有进入过的路由的控制器，依赖其自动生成的功能。然而不幸地是这样经常会导致一些小问题。当进入一个路由时，Ember查找一个与其名字对应的控制器。如果控制器没有找到，Ember会根据路由的模型的类型为其生成一个。如果模型是一个数组，那么将生成一个&lt;code&gt;ArrayController&lt;/code&gt;；如果是一个对象，那么则生成一个&lt;code&gt;ObjectController&lt;/code&gt;；如果两者都不是，则生成一个标准&lt;code&gt;Controller&lt;/code&gt;。在大多数情况下，当在路由之外使用&lt;code&gt;controllerFor&lt;/code&gt;时，并没有提供一个模型，那么Ember会创建一个基础的&lt;code&gt;Controller&lt;/code&gt;。如果之后进入到该路由，这个控制器不会被重新创建，那么控制器的类型就可能与提供的model不匹配。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;今天Ember.js 1.0 RC7发布了！如果一切顺利，这将是Ember 1.0的倒数第二个RC版本。RC7中修复了许多Bug，同时也包括了一些小的改进。另外还有一些Bug还在修正中，由于RC7已经逾期了，因此不等修正所有的Bug。下周将发布RC8，下面内容包含了本次发布做的一些修改。&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;重要改变&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_code-route-controllerfor-code'&gt;&lt;code&gt;Route#controllerFor&lt;/code&gt;不再自动生成控制器&lt;/h4&gt;
&lt;p&gt;有的时候，人们依赖&lt;code&gt;controllerFor&lt;/code&gt;来访问没有进入过的路由的控制器，依赖其自动生成的功能。然而不幸地是这样经常会导致一些小问题。当进入一个路由时，Ember查找一个与其名字对应的控制器。如果控制器没有找到，Ember会根据路由的模型的类型为其生成一个。如果模型是一个数组，那么将生成一个&lt;code&gt;ArrayController&lt;/code&gt;；如果是一个对象，那么则生成一个&lt;code&gt;ObjectController&lt;/code&gt;；如果两者都不是，则生成一个标准&lt;code&gt;Controller&lt;/code&gt;。在大多数情况下，当在路由之外使用&lt;code&gt;controllerFor&lt;/code&gt;时，并没有提供一个模型，那么Ember会创建一个基础的&lt;code&gt;Controller&lt;/code&gt;。如果之后进入到该路由，这个控制器不会被重新创建，那么控制器的类型就可能与提供的model不匹配。&lt;/p&gt;

&lt;p&gt;鉴于此，取消了&lt;code&gt;controllerFor&lt;/code&gt;自动生成控制器的功能。在大多数应用中，这不会导致任何问题，但是如果之前依赖于这个行为，那么就需要更新应用。如果有一个控制器没有与一个路由关联，那么应该显示定义控制器的类，而不再依赖自动生成。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_code-old-router-code'&gt;删除&lt;code&gt;old-router&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Ember旧有的路由在第一个RC版本的时候就已经废除，并且不在被包含在标准RC中，但一些用户依然使用旧的路由。尽管这样，也是时候剪断这个联系了。越来越多新功能的增加，特别是容器，已经与旧的路由不兼容。因此，从Ember代码库中把旧路由的代码删除，不再支持自定义的Ember构建包含旧路由。强烈建议还在使用旧路由的用户升级到新的路由。不过如果有人对维护一个不依赖于Ember主库的旧路由库，可以告诉Ember开发团队。&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;其他改变&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;升级Handlebars版本至1.0.0&lt;/strong&gt; - Handlebars
1.0.0几乎与RC6同时发布。但是不幸的是之前并没有更新至1.0.0版本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;mergedProperties&lt;/code&gt; -
与&lt;code&gt;concatenatedProperties&lt;/code&gt;类似但是是提供给对象的。其将两个基本对象的属性合并为一个对象。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;废除&lt;code&gt;template&lt;/code&gt;，倾向&lt;code&gt;partial&lt;/code&gt;&lt;/strong&gt; -
这两个方法存在重叠。最终定为&lt;code&gt;partial&lt;/code&gt;并且不在需要一个基于下划线开头的名称。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;更新Backburner.js（Ember的RunLoop）-
修正了&lt;code&gt;debounce&lt;/code&gt;添加&lt;code&gt;throttle&lt;/code&gt;&lt;/strong&gt; -
之前&lt;code&gt;Ember.run.debounce&lt;/code&gt;实际上提供节流作用。&lt;code&gt;debounce&lt;/code&gt;现在执行防抖，而节流行为被移至&lt;code&gt;Ember.run.throttle&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;路由可以通过&lt;code&gt;controllerName&lt;/code&gt;指定其控制器的类名。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加&lt;code&gt;Ember.Route#disconnectOutlet&lt;/code&gt;，允许清楚之前渲染的outlet。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为Router.map添加功能，允许其可以多次调用，不再覆盖之前的映射。允许在运行期添加路由。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;更新：&lt;/em&gt;之前建议在控制器没有关联到一个路由时，使用&lt;code&gt;Route#generateController&lt;/code&gt;。现在建议显示的声明控制器的类来取代依赖生成。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Windows下Ember应用开发环境搭建</title>
    <link rel="alternate" href="/blog/2013/08/14/setup-an-ember-app-on-windows-with-yeoman.html"/>
    <id>/blog/2013/08/14/setup-an-ember-app-on-windows-with-yeoman.html</id>
    <published>2013-08-14T00:00:00Z</published>
    <updated>2013-08-14T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;环境：windows 7&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_nodejs'&gt;安装nodejs&lt;/h3&gt;&lt;h3 class='anchorable-toc' id='toc_grunt'&gt;安装grunt&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_grunt-grunt-cli'&gt;安装grunt命令行工具grunt-cli&lt;/h4&gt;
&lt;p&gt;执行全局安装&lt;/p&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  # grunt 必须依赖
  npm install -g grunt-cli
  # 生成项目脚手架 grunt-init --help
  npm install -g grunt-init
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_yeoman'&gt;安装Yeoman&lt;/h3&gt;
&lt;p&gt;Yeoman 是 yo + bower + grunt&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;yo:   生成 项目脚手架&lt;/li&gt;
&lt;li&gt;bower: 包管理工具&lt;/li&gt;
&lt;/ul&gt;
</summary>
    <content type="html">&lt;p&gt;环境：windows 7&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_nodejs'&gt;安装nodejs&lt;/h3&gt;&lt;h3 class='anchorable-toc' id='toc_grunt'&gt;安装grunt&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_grunt-grunt-cli'&gt;安装grunt命令行工具grunt-cli&lt;/h4&gt;
&lt;p&gt;执行全局安装&lt;/p&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  # grunt 必须依赖
  npm install -g grunt-cli
  # 生成项目脚手架 grunt-init --help
  npm install -g grunt-init
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_yeoman'&gt;安装Yeoman&lt;/h3&gt;
&lt;p&gt;Yeoman 是 yo + bower + grunt&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;yo:   生成 项目脚手架&lt;/li&gt;
&lt;li&gt;bower: 包管理工具&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  npm install -g yo
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;自动安装grunt 和 bower&lt;/p&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  # 生成项目脚手架
  npm install -g generator-webapp
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_'&gt;准备项目文件夹&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;创建项目文件夹&lt;/h4&gt;&lt;h4 class='anchorable-toc' id='toc_grunt'&gt;安装grunt及插件，安装在项目根目录&lt;/h4&gt;
&lt;p&gt;进入项目根目录&lt;/p&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  npm install grunt --save-dev
  npm install grunt-contrib-qunit --save-dev
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;验证版本 &lt;code&gt;grunt -version&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight  "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  grunt-cli v0.1.9
  grunt v0.4.1
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;创建一个项目脚手架代码&lt;/h4&gt;&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  yo wabapp
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;查看目录下的文件，自动生成 package.json 和 Gruntfile&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;安装依赖的模块&lt;/h4&gt;&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  npm install
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_'&gt;运行&lt;/h3&gt;&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  grunt server --force
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;http://localhost:9000 出现欢迎页面&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember'&gt;与ember集成&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_ember'&gt;下载ember相关包&lt;/h4&gt;&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  bower install ember
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;app 目录下自动生成 bower_components&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;安装模版编译插件&lt;/h4&gt;&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  npm install grunt-ember-templates --save-dev
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;建立模版文件夹 templates&lt;/p&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  mkdir app/templates
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_gruntfile-js'&gt;修改Gruntfile.js 自动编译模版&lt;/h4&gt;
&lt;p&gt;在Gruntfile.js文件添加&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  grunt.loadNpmTasks(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;grunt-ember-templates&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在grunt.initConfig内添加&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;emberTemplates: {
  &lt;span class="key"&gt;compile&lt;/span&gt;: {
    &lt;span class="key"&gt;options&lt;/span&gt;: {
      &lt;span class="function"&gt;templateName&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(sourceFile) {
        &lt;span class="keyword"&gt;return&lt;/span&gt; sourceFile.replace(&lt;span class="regexp"&gt;&lt;span class="delimiter"&gt;/&lt;/span&gt;&lt;span class="content"&gt;app&lt;/span&gt;&lt;span class="content"&gt;\/&lt;/span&gt;&lt;span class="content"&gt;templates&lt;/span&gt;&lt;span class="content"&gt;\/&lt;/span&gt;&lt;span class="delimiter"&gt;/&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
      }
    },
    &lt;span class="key"&gt;files&lt;/span&gt;: {
      &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;&amp;lt;%= yeoman.app %&amp;gt;/scripts/templates.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: [&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;&amp;lt;%= yeoman.app%&amp;gt;/templates/**/*.handlebars&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;]
    }
  }
},
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 watch处添加如下内容：&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;emberTemplates: {
    &lt;span class="key"&gt;files&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;&amp;lt;%= yeoman.app %&amp;gt;/templates/**/*.handlebars&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;tasks&lt;/span&gt;: [&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;emberTemplates&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;]
},
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后添加emberTemplates到server任务&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;grunt.registerTask(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;server&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt; (target) {
    ...
    grunt.task.run([
        ...
        &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;compass:server&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
        &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; emberTemplates&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="comment"&gt;// Add this line.&lt;/span&gt;
        &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;livereload-start&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
        ...
    ]);
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_'&gt;开发一个简单应用&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_app-scripts-main-js'&gt;在app/scripts/main.js 中 添加如下代码&lt;/h4&gt;&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App = Em.Application.create({
  &lt;span class="key"&gt;rootElement&lt;/span&gt;: &lt;span class="predefined"&gt;$&lt;/span&gt;(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;#app&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),
});

App.Router.map(&lt;span class="keyword"&gt;function&lt;/span&gt;(){
  &lt;span class="local-variable"&gt;this&lt;/span&gt;.route(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;about&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_index-html'&gt;在 index.html&lt;/h4&gt;&lt;div class="highlight html "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt; &lt;span class="tag"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="attribute-name"&gt;id&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;app&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; &lt;span class="attribute-name"&gt;class&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;container&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;   
 &lt;span class="tag"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;添加js文件&lt;/p&gt;
&lt;div class="highlight html "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  &lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;bower_components/jquery/jquery.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;       
  &lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;bower_components/handlebars/handlebars.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;bower_components/ember/ember.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;

  &lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;scripts/main.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;scripts/templates.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;建立模版&lt;/h4&gt;
&lt;p&gt;在 app/templates目录下建立模版文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;application.handlebars&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  &lt;span class="tag"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;My App&lt;span class="tag"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;outlet&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;index.handlebars&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  &lt;span class="tag"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;My App&lt;span class="tag"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;index&lt;span class="tag"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;linkTo&lt;/span&gt; &lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="attribute-name"&gt;about&lt;/span&gt;&lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;About&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;linkTo&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;about.handlebars&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  &lt;span class="tag"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;About&lt;span class="tag"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;linkTo&lt;/span&gt; &lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="attribute-name"&gt;index&lt;/span&gt;&lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;index&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;linkTo&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;运行&lt;/h4&gt;&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  grunt server --force
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;http://localhost:9000 出现欢迎页面，内容如下：&lt;/p&gt;

&lt;p&gt;My App
  index
  About&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_grunt-gruntfile-js'&gt;下一步，修改 grunt Gruntfile.js&lt;/h3&gt;
&lt;p&gt;对components、controllers、models、routes、views等js文件进行合并和压缩。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember.js 1.0.0-rc6发布</title>
    <link rel="alternate" href="/blog/2013/07/06/ember-js-1-0-0-rc6.html"/>
    <id>/blog/2013/07/06/ember-js-1-0-0-rc6.html</id>
    <published>2013-07-06T00:00:00Z</published>
    <updated>2013-07-06T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;Ember.js 1.0 RC6 发布，可以在官方网站&lt;a href="http://builds.emberjs.com"&gt;builds.emberjs.com&lt;/a&gt;下载。本次发布主要有个大的更新：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;路由器更新&lt;/li&gt;
&lt;li&gt;Ember组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;路由更新&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最大的修改就是路由器更新（或“路由整容”），围绕两个方面的主要问题：第一是基于URL的转换与&lt;code&gt;transitionTo&lt;/code&gt;的语义不一致。第二是异步支持不够好，使得很难在路由入口的地方实现一些禁止和延时的操作，比如身份验证和异步代码加载。&lt;/p&gt;

&lt;p&gt;Ember现在统一了URL改变和&lt;code&gt;transitionTo&lt;/code&gt;的语义，并且采用了Promise来增强异步行为。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;Ember.js 1.0 RC6 发布，可以在官方网站&lt;a href="http://builds.emberjs.com"&gt;builds.emberjs.com&lt;/a&gt;下载。本次发布主要有个大的更新：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;路由器更新&lt;/li&gt;
&lt;li&gt;Ember组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;路由更新&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最大的修改就是路由器更新（或“路由整容”），围绕两个方面的主要问题：第一是基于URL的转换与&lt;code&gt;transitionTo&lt;/code&gt;的语义不一致。第二是异步支持不够好，使得很难在路由入口的地方实现一些禁止和延时的操作，比如身份验证和异步代码加载。&lt;/p&gt;

&lt;p&gt;Ember现在统一了URL改变和&lt;code&gt;transitionTo&lt;/code&gt;的语义，并且采用了Promise来增强异步行为。&lt;/p&gt;

&lt;p&gt;此外，路由的转换被提升到最高级别，并且为其添加了新的钩子，可以实现禁止或者修饰转换：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;willTransition&lt;/code&gt;：无论什么时候一个转换将发生时将触发该钩子。
&lt;code&gt;beforeModel&lt;/code&gt;/&lt;code&gt;model&lt;/code&gt;/&lt;code&gt;afterModel&lt;/code&gt;：这些钩子在异步验证期间被触发。&lt;/p&gt;

&lt;p&gt;最后，还有一个&lt;code&gt;error&lt;/code&gt;事件，当无论什么时候，如果出现拒绝的承诺或者在&lt;code&gt;beforeModel&lt;/code&gt;/&lt;code&gt;model&lt;/code&gt;/&lt;code&gt;afterModel&lt;/code&gt;中有错误被抛出都会出发该事件。&lt;/p&gt;

&lt;p&gt;更多的关于路由新特性的介绍，请参看：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://machty.s3.amazonaws.com/ember-facelift-presentation/index.html#/1"&gt;新路由概述（Alex Matchneer六月在Ember
NYC见面会上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/machty/5647589"&gt;使用实例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.embercasts.com/episodes/client-side-authentication-part-2"&gt;客户端身份验证（二）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Ember组件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外一个重要的改变就是Ember组件，其采用了Web组件的推动创建高层次的可重用的页面元素目标。&lt;/p&gt;

&lt;p&gt;Ember组件由一个&lt;code&gt;模板&lt;/code&gt;和一个&lt;code&gt;视图&lt;/code&gt;构成，其封装了&lt;code&gt;模板&lt;/code&gt;的属性的访问和操作。所有外部构建的引用通过传递给&lt;code&gt;视图&lt;/code&gt;的上下文信息来处理。组件可以通过自定义子类来实现。&lt;/p&gt;

&lt;p&gt;Ember组件命名惯例：&lt;/p&gt;

&lt;p&gt;1）&lt;code&gt;模板&lt;/code&gt;名以&amp;#39;components/&amp;#39;开头；
2）组件名称必须包含&amp;#39;-&amp;#39;（这与Web组件标准保持一致，可以避免与包裹HTML元素的内置控件发生冲突）。例如，一个组件可能被命名为&lt;code&gt;&amp;#39;radio-button&amp;#39;&lt;/code&gt;。它的&lt;code&gt;模板&lt;/code&gt;就是&lt;code&gt;&amp;#39;components/radio-button&amp;#39;&lt;/code&gt;，在其他的&lt;code&gt;模板&lt;/code&gt;中用&lt;code&gt;{{radio-button}}&lt;/code&gt;调用。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>第七期周报</title>
    <link rel="alternate" href="/blog/2013/06/14/ember-js-weekly.html"/>
    <id>/blog/2013/06/14/ember-js-weekly.html</id>
    <published>2013-06-14T00:00:00Z</published>
    <updated>2013-06-14T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;本期周报主要介绍与测试相关的内容：&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;读物&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhyyrsa-tdd-ember-js-a'&gt;&lt;a href="http://t.cn/zHYYrSA"&gt;如何TDD开发Ember.js应用&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;文中详细介绍了如何使用jasmine来进行Ember.js应用的TDD开发。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhytx8y-jasmine-ember-js-a'&gt;&lt;a href="http://t.cn/zHYTx8y"&gt;使用jasmine测试Ember.js的模板&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;文中介绍了如何使用jasmine来对Ember.js的模板进行单元测试。&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;视频&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhyyjea-ember-js-a'&gt;&lt;a href="http://t.cn/zHYYJeA"&gt;简捷的测试Ember.js应用&lt;/a&gt;&lt;/h4&gt;</summary>
    <content type="html">&lt;p&gt;本期周报主要介绍与测试相关的内容：&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;读物&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhyyrsa-tdd-ember-js-a'&gt;&lt;a href="http://t.cn/zHYYrSA"&gt;如何TDD开发Ember.js应用&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;文中详细介绍了如何使用jasmine来进行Ember.js应用的TDD开发。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhytx8y-jasmine-ember-js-a'&gt;&lt;a href="http://t.cn/zHYTx8y"&gt;使用jasmine测试Ember.js的模板&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;文中介绍了如何使用jasmine来对Ember.js的模板进行单元测试。&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;视频&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhyyjea-ember-js-a'&gt;&lt;a href="http://t.cn/zHYYJeA"&gt;简捷的测试Ember.js应用&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ember-testing库的作者Erik Bryn主讲的如何使用ember-testing来测试Ember.js应用。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhyykah-konacha-ember-js-a'&gt;&lt;a href="http://t.cn/zHYYkah"&gt;使用Konacha来测试Ember.js应用&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;视频中演示了一个结合Konacha来进行的Ember.js应用验收测试过程。对应该视频的演讲稿&lt;a href="http://t.cn/zHYTwyf"&gt;http://t.cn/zHYTwyf&lt;/a&gt;&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;库、代码和工具&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhyyobo-bloggr-client-rails-a'&gt;&lt;a href="http://t.cn/zHYYObo"&gt;bloggr-client-rails&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一个介绍如何使用QUnit和ember-testing来进行集成测试的例子。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhyh6er-jsfiddle-mocha-ember-js-a'&gt;&lt;a href="http://t.cn/zHYH6er"&gt;jsfiddle上使用mocha对Ember.js进行测试的实例&lt;/a&gt;&lt;/h4&gt;&lt;h4 class='anchorable-toc' id='toc_a-href-http-t-cn-zhyhleq-jsfiddle-qunit-ember-js-a'&gt;&lt;a href="http://t.cn/zHYHlEQ"&gt;jsfiddle上使用QUnit对Ember.js进行测试的实例&lt;/a&gt;&lt;/h4&gt;</content>
  </entry>
  <entry>
    <title>Ember.js 1.0.0-rc5发布</title>
    <link rel="alternate" href="/blog/2013/06/01/ember-js-1-0-0-rc5.html"/>
    <id>/blog/2013/06/01/ember-js-1-0-0-rc5.html</id>
    <published>2013-06-01T00:00:00Z</published>
    <updated>2013-06-01T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;今天是快乐的六一儿童节，Ember.js 1.0 RC5也在这一天发布了。本次发布预示着我们等待已久的Ember.js 1.0正式版马上就要横空出世了。&lt;/p&gt;

&lt;p&gt;RC5中主要修复了在RC4中发现的回归问题和缺陷。主要包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;修复了因为改动了运行循环计划而导致的性能问题。&lt;/li&gt;
&lt;li&gt;修复了如果路由的模型钩子返回承诺（Promise）页面刷新时会挂起的问题。&lt;/li&gt;
&lt;li&gt;包含辅助测试方法的ember-testing不在包含在生产构建中。这意味着介绍了用户需要从网络加载的Javascript代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细的修订记录：&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;今天是快乐的六一儿童节，Ember.js 1.0 RC5也在这一天发布了。本次发布预示着我们等待已久的Ember.js 1.0正式版马上就要横空出世了。&lt;/p&gt;

&lt;p&gt;RC5中主要修复了在RC4中发现的回归问题和缺陷。主要包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;修复了因为改动了运行循环计划而导致的性能问题。&lt;/li&gt;
&lt;li&gt;修复了如果路由的模型钩子返回承诺（Promise）页面刷新时会挂起的问题。&lt;/li&gt;
&lt;li&gt;包含辅助测试方法的ember-testing不在包含在生产构建中。这意味着介绍了用户需要从网络加载的Javascript代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细的修订记录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为不正确的容器搜索名称添加断言&lt;/li&gt;
&lt;li&gt;增加了&lt;code&gt;Ember.beforeObserver&lt;/code&gt;的文档&lt;/li&gt;
&lt;li&gt;从生产构建中移除了ember-testing&lt;/li&gt;
&lt;li&gt;修复了承诺（Promise）在启动时的缺陷。修复 #2756&lt;/li&gt;
&lt;li&gt;同步router.js修复&lt;code&gt;App#reset&lt;/code&gt;在ember-testing中的问题&lt;/li&gt;
&lt;li&gt;声明&lt;code&gt;replaceWith&lt;/code&gt;只工作在&amp;#39;history&amp;#39;模式下&lt;/li&gt;
&lt;li&gt;修正了IE7下测试不通过的问题&lt;/li&gt;
&lt;li&gt;更新backburner，修复IE8下测试失败的问题&lt;/li&gt;
&lt;li&gt;更新Backburner.js修复RC4中的性能问题&lt;/li&gt;
&lt;li&gt;维护gem包的ruby版本&lt;/li&gt;
&lt;li&gt;移除starter_kit上传任务&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
