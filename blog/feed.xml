<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EmberJS.CN Blog</title>
  <subtitle>Ember JS相关新闻与资源</subtitle>
  <id>http://emberjs.cn/blog</id>
  <link href="http://emberjs.cn/blog"/>
  <link href="http://emberjs.cn/blog/feed.xml" rel="self"/>
  <updated>2014-01-14T00:00:00Z</updated>
  <author>
    <name>EmberJS.CN</name>
  </author>
  <entry>
    <title>安全性发布 - Ember 1.0.1, 1.1.3, 1.2.1, and 1.3.1</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2014/01/14/ember-security-releases.html"/>
    <id>http://emberjs.cn/blog/2014/01/14/ember-security-releases.html</id>
    <published>2014-01-14T00:00:00Z</published>
    <updated>2014-01-14T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;因为开发者信任Ember.js在生产环境下来处理敏感的用户数据，因此Ember团队非常关注项目的安全问题。实际上，Ember是少数具有&lt;a href="http://emberjs.com/security/"&gt;清晰的安全策略&lt;/a&gt;和一个&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;为安全问题专设的邮件列表&lt;/a&gt;的Javascript项目之一。&lt;/p&gt;

&lt;p&gt;今天发布的Ember.js
1.0.1，1.1.3，1.2.1，1.3.1和1.4.0-beta.2包含下面的重要的安全修复：&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;因为开发者信任Ember.js在生产环境下来处理敏感的用户数据，因此Ember团队非常关注项目的安全问题。实际上，Ember是少数具有&lt;a href="http://emberjs.com/security/"&gt;清晰的安全策略&lt;/a&gt;和一个&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;为安全问题专设的邮件列表&lt;/a&gt;的Javascript项目之一。&lt;/p&gt;

&lt;p&gt;今天发布的Ember.js
1.0.1，1.1.3，1.2.1，1.3.1和1.4.0-beta.2包含下面的重要的安全修复：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.4.0-beta.2 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.4.0-beta.1...v1.4.0-beta.2"&gt;对比视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.3.1 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.3.0...v1.3.1"&gt;对比视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.2.1 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.2.0...v1.2.1"&gt;对比视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.1.3 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.1.2...v1.1.3"&gt;对比视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.0.1 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.0.0...v1.0.1"&gt;对比视图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本次修复包含两个潜在的XSS漏洞，可以通过下面两个链接获取更多信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://groups.google.com/forum/#!topic/ember-security/2kpXXCxISS4"&gt;CVE-2014-0013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://groups.google.com/forum/#!topic/ember-security/PSE4RzTi6l4"&gt;CVE-2014-0014&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;推荐马上更新项目。为了方便升级，本次发布的版本主要只包含了安全修复（1.4.0-beta.2除外，该版本是一个常规的beta发布，并包含了此次的安全修复）。&lt;/p&gt;

&lt;p&gt;如果在生产环境下使用Ember.js，请考虑订阅&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;安全通知邮件列表&lt;/a&gt;。该邮件列表流量非常低，且只包含安全通知。&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_'&gt;更多内容&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2013/04/05/announcing-the-ember-security-policy.html"&gt;Ember.js安全策略公告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/security/"&gt;Ember.js安全策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;Ember.js安全组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ember 1.3.0 and 1.4 Beta Released</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2014/01/06/ember-1-3-0-and-ember-1-4-0-beta-released.html"/>
    <id>http://emberjs.cn/blog/2014/01/06/ember-1-3-0-and-ember-1-4-0-beta-released.html</id>
    <published>2014-01-06T00:00:00Z</published>
    <updated>2014-01-06T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;We are pleased to announce that both Ember.js 1.3.0 and the first beta in the 1.4 series
have just been released. This comes as the third cycle of our six-week release
process that began just after 1.0 was released.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_new-in-1-3'&gt;New in 1.3&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_non-array-dependencies-for-reducecomputed'&gt;Non-array Dependencies for ReduceComputed&lt;/h4&gt;</summary>
    <content type="html">&lt;p&gt;We are pleased to announce that both Ember.js 1.3.0 and the first beta in the 1.4 series
have just been released. This comes as the third cycle of our six-week release
process that began just after 1.0 was released.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_new-in-1-3'&gt;New in 1.3&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_non-array-dependencies-for-reducecomputed'&gt;Non-array Dependencies for ReduceComputed&lt;/h4&gt;
&lt;p&gt;Generally, using &lt;code&gt;reduceComputed&lt;/code&gt; is all about efficiently computing the resulting value, but
occasionally you might need to recompute every time. It is now possible to instruct
&lt;code&gt;reduceComputed&lt;/code&gt; to completely recompute when an item is added/removed (instead of calling
the &lt;code&gt;addedItem&lt;/code&gt; and &lt;code&gt;removedItem&lt;/code&gt; callbacks).&lt;/p&gt;

&lt;p&gt;This is done by using either non-array dependent keys or adding &lt;code&gt;.[]&lt;/code&gt; to an array dependency.&lt;/p&gt;

&lt;p&gt;Take a look at the following example:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Ember.Object.extend({
  &lt;span class="comment"&gt;// When `string` is changed, `computed` is completely recomputed.&lt;/span&gt;
  &lt;span class="key"&gt;string&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;a string&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,

  &lt;span class="comment"&gt;// When an item is added to `array`, `addedItem` is called.&lt;/span&gt;
  &lt;span class="key"&gt;array&lt;/span&gt;: [],

  &lt;span class="comment"&gt;// When an item is added to `anotherArray`, `computed` is completely&lt;/span&gt;
  &lt;span class="comment"&gt;// recomputed.&lt;/span&gt;
  &lt;span class="key"&gt;anotherArray&lt;/span&gt;: [],

  &lt;span class="key"&gt;computed&lt;/span&gt;: Ember.reduceComputed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;string&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;array&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;anotherArray.[]&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, {
    &lt;span class="key"&gt;addedItem&lt;/span&gt;: addedItemCallback,
    &lt;span class="key"&gt;removedItem&lt;/span&gt;: removedItemCallback
  })
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_testing'&gt;Testing&lt;/h4&gt;
&lt;p&gt;Testability of Ember applications is an ongoing priority, and the 1.3 release
contains a number of updates that result in a dramatic improvement.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_custom-code-wait-code-hooks'&gt;Custom &lt;code&gt;wait()&lt;/code&gt; Hooks&lt;/h5&gt;
&lt;p&gt;You can now specify custom hooks to notify the asynchronous test helpers when all
async actions have completed. Under Ember 1.2 if you need to wait for an IndexDB
action, the default &lt;code&gt;wait&lt;/code&gt; implementation would not wait until that
action finished. Now you can simply register your own hook that will instruct wait
that it is truly time to continue.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Ember.Test.registerWaiter(&lt;span class="keyword"&gt;function&lt;/span&gt;() {
  &lt;span class="keyword"&gt;return&lt;/span&gt; hasPendingTransactions() == &lt;span class="integer"&gt;0&lt;/span&gt;;
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This instructs the &lt;code&gt;wait&lt;/code&gt; helper that the async actions are not finished until
&lt;code&gt;hasPendingTransactions&lt;/code&gt; is zero.&lt;/p&gt;

&lt;p&gt;You can find more details &lt;a href="https://github.com/emberjs/ember.js/pull/3433"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_lazy-routing'&gt;Lazy Routing&lt;/h5&gt;
&lt;p&gt;Under Ember.js 1.2 routing is started as soon as you boot your application and &lt;em&gt;before&lt;/em&gt;
you call &lt;code&gt;visit&lt;/code&gt;. This results in duplicate routing which slows down your tests and also
potentially causes your tests to be less isolated.&lt;/p&gt;

&lt;p&gt;Under Ember.js 1.3 routing isn&amp;#39;t started until you call &lt;code&gt;visit&lt;/code&gt; for the first time. This
provides a couple of improvements to the way you test:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You do not need to call &lt;code&gt;App.advanceReadiness()&lt;/code&gt; in your test setup since the application
is automatically in a deferred state until calling &lt;code&gt;visit&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;App.reset()&lt;/code&gt; now leaves the application in the same state as &lt;code&gt;App.setupForTesting()&lt;/code&gt; (a
deferred state).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can find more details &lt;a href="https://github.com/emberjs/ember.js/pull/3695"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_stubbable-code-controllers-code-property'&gt;Stubbable &lt;code&gt;controllers&lt;/code&gt; Property&lt;/h5&gt;
&lt;p&gt;Prior to Ember 1.3 you could not easily stub out any dependencies specified with &lt;code&gt;needs&lt;/code&gt;.
Now you can unit test controllers and stub their dependencies all within
&lt;code&gt;TheControllerClass.create()&lt;/code&gt; instead of having to use a container, register stubbed
dependencies, and instantiate the controller via &lt;code&gt;container.lookup()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Simplified example:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; BrotherController = Ember.Controller.extend({
  &lt;span class="key"&gt;needs&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;sister&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;foo&lt;/span&gt;: Ember.computed.alias(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;controllers.sister.foo&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});

&lt;span class="keyword"&gt;var&lt;/span&gt; broController = BrotherController.create({
  &lt;span class="key"&gt;controllers&lt;/span&gt;: {
    &lt;span class="key"&gt;sister&lt;/span&gt;: { &lt;span class="key"&gt;foo&lt;/span&gt;: &lt;span class="integer"&gt;5&lt;/span&gt; }
  }
});

equal(broController.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;foo&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;), &lt;span class="integer"&gt;5&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;`needs` dependencies can be stubbed&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Previously, specifying &lt;code&gt;controllers&lt;/code&gt; to &lt;code&gt;BrotherController&lt;/code&gt; would have resulted in an error,
and now under Ember.js 1.3 this works as expected.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_promise-improvements'&gt;Promise Improvements&lt;/h4&gt;
&lt;p&gt;Ember.js 1.3 has updated to &lt;code&gt;RSVP&lt;/code&gt; 3.0.3 which brings considerable performance improvements, a number
of new features, and significantly improved documentation coverage.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RSVP&lt;/code&gt; has added a number of features that allow external tooling to be able to inspect and track the labels, states, and
values of promises. These improvements will be extremely useful when used with the next major
version of the &lt;a href="https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi"&gt;Ember Inspector&lt;/a&gt;.
Which will allow you to see a tree of promises and inspect their names, state, and fulfilled/rejected values.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RSVP&lt;/code&gt; added a number of additional methods to &lt;code&gt;Promise&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Promise.cast&lt;/code&gt; - Coerces the given argument into a promise, or returns the argument if it is
already a promise.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Promise.catch&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; is essentially syntactic sugar for &lt;code&gt;then(undefined, onRejection)&lt;/code&gt; which
makes it the same as the &lt;code&gt;catch&lt;/code&gt; block of a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Promise.finally&lt;/code&gt; - The callback provided to &lt;code&gt;Promise.finally&lt;/code&gt; will be invoked regardless of the
promises fate (both fulfilled and rejected promises). This is essentially similar to native
&lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt; statements.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Promise.race&lt;/code&gt; - Will return a new promise which will be settled with the value of
the first promise that settles. In other words: given an array of promises &lt;code&gt;Promise.race&lt;/code&gt;
will return the value from the first argument that settles (like the winner in a &amp;quot;race&amp;quot;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please review &lt;a href="/api/modules/RSVP.html"&gt;the documentation&lt;/a&gt; for more information.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_other-improvements'&gt;Other Improvements&lt;/h4&gt;
&lt;p&gt;As usual, there are a ton of bug fixes and small improvements in this
release. You can see a list of all the changes in the CHANGELOG:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.3.0/CHANGELOG.md"&gt;Ember.js 1.3.0 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.4.0-beta.1/CHANGELOG.md"&gt;Ember.js 1.4.0 beta 1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>What's Coming in Ember in 2014</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2013/12/17/whats-coming-in-ember-in-2014.html"/>
    <id>http://emberjs.cn/blog/2013/12/17/whats-coming-in-ember-in-2014.html</id>
    <published>2013-12-17T00:00:00Z</published>
    <updated>2013-12-17T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;Every few months, the Ember core team likes to get together to discuss
issues face-to-face and set our priorities for the following quarter.&lt;/p&gt;

&lt;p&gt;This time, we all converged on Portland, Oregon for the weekend to
figure out where to focus our energy in 2014.&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;Every few months, the Ember core team likes to get together to discuss
issues face-to-face and set our priorities for the following quarter.&lt;/p&gt;

&lt;p&gt;This time, we all converged on Portland, Oregon for the weekend to
figure out where to focus our energy in 2014.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_build-tools-modules'&gt;Build Tools &amp;amp; Modules&lt;/h2&gt;
&lt;p&gt;We spent the majority of our time discussing a unified plan that
combines ES6 modules with fast, robust, full-featured build tools for
Ember developers.&lt;/p&gt;

&lt;p&gt;One thing I love about the Ember community is that it values quality
over raw implementation speed. For us, it&amp;#39;s more important &lt;a href="http://merrickchristensen.com/articles/scenario-vs-problem-solving.html"&gt;to solve
problems than to solve
scenarios&lt;/a&gt;,
because scenario solving leads to fragmented solutions that don&amp;#39;t scale
or compose as your app grows.&lt;/p&gt;

&lt;p&gt;So far, we&amp;#39;ve held off on endorsing any particular build tool because,
while we&amp;#39;ve investigated all of them thoroughly, the currently-available
options all have fatal flaws that make them unpleasant to use as your
app gets larger.&lt;/p&gt;

&lt;p&gt;Many people have also been asking us about modules. When we started
Ember, there were no popular module formats. Since then, both CommonJS
modules on the server and AMD modules in the browser have exploded in
popularity. While both are great options, their ecosystems are
disconnected and the two communities frequently engage in emacs/vi-style
holy wars.&lt;/p&gt;

&lt;p&gt;Fortunately, TC39, the committee in charge of maintaining JavaScript,
recognized the need for a unified module system. ES6 modules offer the
best of both AMD and CommonJS modules while being integrated directly
into the language.&lt;/p&gt;

&lt;p&gt;Just as the Ember community was one of the first to fully embrace
JavaScript promises, we have spent the last few months working on making
ES6 modules a reality and bringing them to production.&lt;/p&gt;

&lt;p&gt;Two notable projects have come out of this work:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.thomasboyt.com/2013/06/21/es6-module-transpiler"&gt;ES6 Module Transpiler&lt;/a&gt;,
which can transpile JavaScript written in the ES6 module syntax down
into browser globals, AMD or CommonJS.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://embersherpa.com/articles/introduction-to-ember-app-kit/"&gt;Ember App Kit&lt;/a&gt;, a foundation
for building Ember apps that uses ES6 modules (via the transpiler)
instead of globals.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;#39;s important to note that we have been planning for module support for
some time. In fact, one of the last features that was blocking our
initial 1.0 release was to have the entire framework go through an object
called the &lt;em&gt;resolver&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The resolver is the part of our dependency injection system that is
responsible for determining naming conventions. For example, imagine a
user visits your Ember application at &lt;code&gt;/posts&lt;/code&gt;. By default, Ember will
look for a template called &lt;code&gt;posts&lt;/code&gt;, ask the &lt;code&gt;App.PostsRoute&lt;/code&gt; for a
model, and hook it all up to the &lt;code&gt;App.PostsController&lt;/code&gt;. But these
globals are not hardcoded into the framework—instead, there&amp;#39;s a default
resolver that encapsulates all of these naming conventions.&lt;/p&gt;

&lt;p&gt;To write an Ember app that uses modules, it&amp;#39;s as simple as swapping out
the default resolver for one that requires named modules instead of
looking for globals.&lt;/p&gt;

&lt;p&gt;In order to make it really nice, however, we believe we need
command-line tools to smooth the process of creating, developing, and
deploying apps.&lt;/p&gt;

&lt;p&gt;Our focus for the first quarter of 2014 will be to develop first-class
build tools that leverage existing tools where they fit our needs, and
write new ones where the current options fall down. We&amp;#39;ll make modules a
first-class citizen, and soon every developer who starts using Ember
will also be using ES6 modules. We&amp;#39;re excited about a world where
browser and server JavaScript packages live together in harmony.&lt;/p&gt;

&lt;p&gt;To give you an idea of what we&amp;#39;re thinking, here are some example CLI
commands and their effects. Note that this is all under heavy
development and is subject to change.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_initializing-an-app'&gt;Initializing an App&lt;/h3&gt;&lt;div class="highlight sh "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;ember new my-app
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This initializes a new Ember.js project and generates stub directories,
an app, a router, etc.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_starting-the-development-server'&gt;Starting the Development Server&lt;/h3&gt;&lt;div class="highlight sh "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;ember server
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_running-tests'&gt;Running Tests&lt;/h3&gt;&lt;div class="highlight sh "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;ember test
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Runs the QUnit tests using Karma (PhantomJS plus available
browsers), although we are planning migrate to testem as we&amp;#39;ve found its
output easier to work with.&lt;/p&gt;

&lt;p&gt;You can also host the QUnit test harness for manual testing by
running:&lt;/p&gt;
&lt;div class="highlight sh "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;ember test:server
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h2 class='anchorable-toc' id='toc_adding-packages'&gt;Adding Packages&lt;/h2&gt;
&lt;p&gt;The Ember CLI supports bower natively. Just use the commands
you&amp;#39;re used to:&lt;/p&gt;
&lt;div class="highlight sh "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;bower install moment
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The lingua franca module format in Ember is ES6 modules. We will do the
work to ensure that bower modules are usable by Ember apps
automatically, by shimming AMD, CommonJS and browser global packages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Provide a &lt;code&gt;shim.json&lt;/code&gt; and &lt;code&gt;shim&lt;/code&gt; directory for AMD shims&lt;/li&gt;
&lt;li&gt;Name anonymous module based on filesystem location (including
versions)&lt;/li&gt;
&lt;li&gt;Concatenate modules into app.js (with source map)&lt;/li&gt;
&lt;li&gt;Inherit source maps from bower (if provided)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Even if a library was shipped as AMD, you would be able to use it as
though it was an ES6 module:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;import&lt;/span&gt; md from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;markdown&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Every time a file changes, the final concatenated file loaded by the
browser (app.js, app.css, etc.) is locked and any HTTP requests for it
block until the new version is compiled.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_enhanced-inspector-features'&gt;Enhanced Inspector Features&lt;/h2&gt;
&lt;p&gt;If you&amp;#39;re developing your app using the Ember CLI tools, the Chrome and
Firefox inspectors get even better. The development server will open a
socket that the inspector can connect to that will provide additional
environmental information to the browser extension.&lt;/p&gt;

&lt;p&gt;There are lots of exciting things you can do once your browser and
development tools are talking to each other, but some of the ideas we&amp;#39;ve
tossed around are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Seeing a list of installed bower packages&lt;/li&gt;
&lt;li&gt;Seeing the results of test runs&lt;/li&gt;
&lt;li&gt;Linting and auditing your codebase&lt;/li&gt;
&lt;li&gt;Configuring package.json using visual editor&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class='anchorable-toc' id='toc_filesystem-layout'&gt;Filesystem Layout&lt;/h2&gt;
&lt;p&gt;Here is a rough example of the kind of layout you might see when
initializing a new Ember app via the CLI:&lt;/p&gt;
&lt;div class="highlight  "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;app/
  controllers/
  models/
  fonts/
  …
config/
  shim.json
vendor/
  underscore.js    // bower installed
  markdown.js
lib/
  ember-histogram/ // incubator for packages
    skylight/
    bower.json 
modules/           // non-MVC stuff
  underscore.js
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_pod-directory-structure'&gt;&amp;quot;Pod&amp;quot; Directory Structure&lt;/h3&gt;
&lt;p&gt;Right now, many Ember projects have adopted a Rails-style directory
layout where everything is grouped by type:&lt;/p&gt;
&lt;div class="highlight  "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;app/
  controllers/
    post.js
    posts.js
    index.js
  models/
    post.js
    user.js
  templates/
    post.handlebars
    posts.handlebars
    index.handlebars
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We discussed moving this to a layout where related features are
grouped together in &amp;quot;pods&amp;quot; of functionality:&lt;/p&gt;
&lt;div class="highlight  "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
17
18
19
&lt;strong&gt;20&lt;/strong&gt;
21
22
23
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;app/
  config/
    application.js
  serializers/
  models/
    post.js
    user.js
  mixins/
pods/
  post/
    controller.js
    template.handlebars
  posts/
    controller.js
    template.handlebars
  index/
    controller.js
    template.handlebars
components/
  google-map/
    component.handlebars
    component.js
    component.css
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This proposed directory structure is still up for lots of discussion.
We&amp;#39;ve been looking at many different real world apps to see if this
makes managing the source code for Ember apps any easier.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_slimming-down-ember-js-project-svelte'&gt;Slimming Down Ember.js (Project Svelte)&lt;/h2&gt;
&lt;p&gt;We believe there are several areas in the Ember codebase that have the
potential to be slimmed down substantially. We&amp;#39;d like to pick a target
filesize and have a sprint to get the total built framework size under
that target.&lt;/p&gt;

&lt;p&gt;We haven&amp;#39;t picked a target size yet, but we tossed around the 50k figure.
We&amp;#39;ll have more information about this once we&amp;#39;ve made a list of good
candidates for slimming action.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_distributing-components'&gt;Distributing Components&lt;/h2&gt;
&lt;p&gt;There are a number of open issues around distributing reusable,
third-party components and libraries of components. Typically we defer
to the Web Components spec, but there are areas where the spec does not
currently provide any guidance. As we deal with them, we are keen to
provide feedback to the Web Components spec authors with how we have
chosen to solve the problems.&lt;/p&gt;

&lt;p&gt;Other limitations are due to certain features not being available in
older browsers, and we are working on polyfilling and working around
those issues so that you can enjoy the power of Web Components today in
browsers all the way back to IE8.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_namespacing'&gt;Namespacing&lt;/h3&gt;
&lt;p&gt;Right now, Ember components share a global namespace. If I have a
component called &lt;code&gt;area-graph&lt;/code&gt; and you have a component called
&lt;code&gt;area-graph&lt;/code&gt; and I want to use your component in my app, we will have a
collision.&lt;/p&gt;

&lt;p&gt;Soon, components in packages will be addressable by a fully-qualified path.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s a notional area graph component:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;area-graph&lt;/span&gt;&lt;span class="error"&gt;@&lt;/span&gt;&lt;span class="attribute-name"&gt;d3&lt;/span&gt; &lt;span class="attribute-name"&gt;xValue&lt;/span&gt;=&lt;span class="attribute-value"&gt;responseTimes&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you find yourself typing the fully-qualified path often, you will be
able to alias the helper in the lexical scope of the Handlebars template:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;import&lt;/span&gt; &lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="attribute-name"&gt;area-graph&lt;/span&gt;&lt;span class="error"&gt;&amp;quot;&lt;/span&gt; &lt;span class="attribute-name"&gt;from&lt;/span&gt; &lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="attribute-name"&gt;d3&lt;/span&gt;&lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We may also add a syntax for making all helpers in a package available:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;import&lt;/span&gt; &lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="attribute-name"&gt;d3&lt;/span&gt;&lt;span class="error"&gt;&amp;quot;&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_template-versioning-compilation'&gt;Template Versioning/Compilation&lt;/h3&gt;
&lt;p&gt;Handlebars compiles templates down into an intermediate AST. This AST
can change between Handlebars versions. Additionally, Handlebars syntax
may be extended, or change in version 2.0. &lt;/p&gt;

&lt;p&gt;Given that components are distributed on bower, should they be shipped
with their templates pre-compiled, or should we leave it up to ember-cli
to compile them on-demand?&lt;/p&gt;

&lt;p&gt;Currently, we are leaning towards shipping templates in their raw source
form, but we need to do some more investigation.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_scoped-css'&gt;Scoped CSS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;style scoped&amp;gt;&lt;/code&gt; is not available today in many browsers. Distributed
components will get a uuid associated with them, and all of their CSS
rules will be wrapped in a selector that limits them to elements with
that uuid as a class name.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_item-controller'&gt;Item Controller&lt;/h2&gt;
&lt;p&gt;Instead of doing &lt;code&gt;{{#each itemController=&amp;quot;postItem&amp;quot;}}&lt;/code&gt;, you can just
define &lt;code&gt;App.PostsItemController&lt;/code&gt; (or the &lt;code&gt;app/controllers/posts-item&lt;/code&gt;
module) and it will be wired up automatically.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_htmlbars'&gt;HTMLBars&lt;/h2&gt;
&lt;p&gt;HTMLBars is on track and will hopefully be available behind a feature
flag sometime in the new year. Yehuda spent some time going over the
implementation with Kris Selden and Alex Matchneer. They are going to be
taking over the effort of integrating the HTMLBars compiler into Ember
proper.&lt;/p&gt;

&lt;p&gt;If you&amp;#39;re not familiar with HTMLBars, it is a compiler that knows about
both HTML5 and Handlebars syntax. This is important for two reasons.&lt;/p&gt;

&lt;p&gt;First, it will allow us to deprecate the &lt;code&gt;{{bind-attr}}&lt;/code&gt; Handlebars
helper. Instead of this:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;img&lt;/span&gt; &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;bind-attr&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="attribute-value"&gt;imageUrl&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You will be able to say:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;img&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;imageUrl&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Second, it will also allow us to eliminate the ugly metamorph.js script
tags that we currently use to track bound values in the DOM.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s what the DOM looks like before HTMLBars:&lt;/p&gt;

&lt;p&gt;&lt;img
src="/images/blog/2013-12-17-whats-coming-in-ember-in-2014/with-metamorph.png"&gt;&lt;/p&gt;

&lt;p&gt;And after:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/2013-12-17-whats-coming-in-ember-in-2014/without-metamorph.png"&gt;&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_eliminate-jquery-dependency'&gt;Eliminate jQuery Dependency&lt;/h2&gt;
&lt;p&gt;Once we move over to HTMLBars, the interaction between Ember.js and the
DOM gets smaller. We can probably treat jQuery as an optional dependency
and only use it if it is available via globals or as an AMD module. We
just want to make sure that we remove components/views using jQuery if its
available so that jQuery UI widgets that have stored data in the DOM via
jQuery.data() get cleaned up appropriately.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_animation'&gt;Animation&lt;/h2&gt;
&lt;p&gt;We&amp;#39;re still working on having animation support be built in to the
framework, but we don&amp;#39;t have any specific API proposals to share at this
time. As always, we prioritize getting the API correct the first time
rather than having to re-do it in a later release.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ie8-support'&gt;IE8 Support&lt;/h2&gt;
&lt;p&gt;Despite the imminent End of Life status of Windows XP, we will continue
supporting Internet Explorer 8. We know many Ember.js users still need
to target enterprise and education customers, who will be on IE8 for
some time.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_emberconf'&gt;EmberConf&lt;/h2&gt;
&lt;p&gt;EmberConf 2014: It&amp;#39;s happening. We&amp;#39;ll have more details available very
soon, but I will say that you should keep March as free as you can.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_emberdart'&gt;EmberDart&lt;/h2&gt;
&lt;p&gt;Just kidding.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_how-you-can-help'&gt;How You Can Help&lt;/h2&gt;
&lt;p&gt;As we&amp;#39;ve said before, Ember is a completely community-driven project.
I&amp;#39;d like to thank all of the core team members who pay out-of-pocket for
travel and accommodation so they can be at these meetings.&lt;/p&gt;

&lt;p&gt;It has been extremely rewarding to watch the Ember community grow, and
also to see it assume a position of leadership in the JavaScript
community.&lt;/p&gt;

&lt;p&gt;We need your help to keep pushing the boundaries of what&amp;#39;s possible in
the browser. If you&amp;#39;d like to get started helping out, please join us in
&lt;code&gt;#emberjs-dev&lt;/code&gt; on Freenode, where our helpful community can point you in
the right direction. (If you just need help with developing your Ember
app, please keep those questions in &lt;code&gt;#emberjs&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;If there&amp;#39;s anything we&amp;#39;ve forgotten to mention here, please feel free to
let us know what you&amp;#39;d like to see in the comments below!&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ember-data'&gt;Ember Data&lt;/h2&gt;
&lt;p&gt;We&amp;#39;ve got lots of exciting stuff coming in Ember Data. Expect an update
on our roadmap there in a separate blog post soon.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/2013-12-17-whats-coming-in-ember-in-2014/1.jpg"&gt;
&lt;img src="/images/blog/2013-12-17-whats-coming-in-ember-in-2014/2.jpg"&gt;
&lt;img src="/images/blog/2013-12-17-whats-coming-in-ember-in-2014/3.jpg"&gt;
&lt;img src="/images/blog/2013-12-17-whats-coming-in-ember-in-2014/4.jpg"&gt;
&lt;img src="/images/blog/2013-12-17-whats-coming-in-ember-in-2014/5.jpg"&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>完成Ember指南中文翻译</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2013/12/05/finish-translations.html"/>
    <id>http://emberjs.cn/blog/2013/12/05/finish-translations.html</id>
    <published>2013-12-05T00:00:00Z</published>
    <updated>2013-12-05T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;Ember.js中文站&lt;a href="http://emberjs.cn"&gt;http://emberjs.cn&lt;/a&gt;，诞生在浪漫的情人节之后的一天。时至今日，已过去了338个日夜。在这期间Ember.js改变了很多：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ember.js从第一个RC走到了如今1.2.0版本的正式发布&lt;/li&gt;
&lt;li&gt;Ember Data也迎来了新的1.0接口的beta发布&lt;/li&gt;
&lt;li&gt;第三方插件也如雨后春笋帮开始涌现到社区&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么我们Ember.js中文站又发生了些什么改变呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先我们完成了指南的中文化工作&lt;/li&gt;
&lt;li&gt;再而我们拥有了供我们中文社区进行交流的平台&lt;/li&gt;
&lt;/ul&gt;
</summary>
    <content type="html">&lt;p&gt;Ember.js中文站&lt;a href="http://emberjs.cn"&gt;http://emberjs.cn&lt;/a&gt;，诞生在浪漫的情人节之后的一天。时至今日，已过去了338个日夜。在这期间Ember.js改变了很多：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ember.js从第一个RC走到了如今1.2.0版本的正式发布&lt;/li&gt;
&lt;li&gt;Ember Data也迎来了新的1.0接口的beta发布&lt;/li&gt;
&lt;li&gt;第三方插件也如雨后春笋帮开始涌现到社区&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么我们Ember.js中文站又发生了些什么改变呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先我们完成了指南的中文化工作&lt;/li&gt;
&lt;li&gt;再而我们拥有了供我们中文社区进行交流的平台

&lt;ul&gt;
&lt;li&gt;论坛：&lt;a href="http://discuss.emberjs.cn"&gt;http://discuss.emberjs.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;QQ群：298026365&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;另外我们还发布了第一个开源项目&lt;a href="https://github.com/emberjs-cn/intimi"&gt;intimi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;中文社区能走到今天，要多谢大家的参与和支持，特别是那些热心于为初学者解惑答疑的朋友们，以及牺牲了很多自己的业余时间参与到指南翻译、Intimi开发的朋友们。&lt;/p&gt;

&lt;p&gt;Ember.js官方指南到今天已经完成了全部的翻译工作，由于翻译工作时间跨度大（338个日夜），参与的人数众多，前期也没有对一些名词，语态进行约定，总体工作完成的还不是很完善，主要表现在如下几个方面：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;与官方指南同步出现差错&lt;/li&gt;
&lt;li&gt;翻译时使用的人称不一致&lt;/li&gt;
&lt;li&gt;翻译结果与原文表达意思有出入&lt;/li&gt;
&lt;li&gt;存在大量的错别字&lt;/li&gt;
&lt;li&gt;等等。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对存在的这些不足，我们在此向大家致歉，同时也希望大家在发现我们的错误的时候，积极的给我们发&lt;a href="https://github.com/emberjs-cn/www.emberjs.cn/issues"&gt;Issue&lt;/a&gt;，或者&lt;a href="https://github.com/emberjs-cn/www.emberjs.cn"&gt;Pull Request&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后，我们再来一同展望一下Ember.js中文站未来一年的发展计划：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;持续跟踪和翻译Ember.js官方文档&lt;/li&gt;
&lt;li&gt;定期撰写Ember.js开发相关技术文档&lt;/li&gt;
&lt;li&gt;开发更多的能简化大家日常开发工作的Ember Package&lt;/li&gt;
&lt;li&gt;组织数次Ember.js技术交流会议/沙龙&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果大家有什么更好的想法，可以拍上来，共谋大业！&lt;/p&gt;

&lt;p&gt;谢谢大家不离不弃的支持！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember 1.0 Released</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2013/08/31/ember-1-0-released.html"/>
    <id>http://emberjs.cn/blog/2013/08/31/ember-1-0-released.html</id>
    <published>2013-08-31T00:00:00Z</published>
    <updated>2013-08-31T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;Today, we&amp;#39;re excited to announce the final release of Ember.js 1.0.&lt;/p&gt;

&lt;p&gt;The first commit to the repository that would become Ember.js happened on April
30th, 2011, almost two and a half years ago.&lt;/p&gt;

&lt;p&gt;At the time, Backbone.js was rocketing to popularity. In response to large&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;Today, we&amp;#39;re excited to announce the final release of Ember.js 1.0.&lt;/p&gt;

&lt;p&gt;The first commit to the repository that would become Ember.js happened on April
30th, 2011, almost two and a half years ago.&lt;/p&gt;

&lt;p&gt;At the time, Backbone.js was rocketing to popularity. In response to large
JavaScript frameworks like SproutCore, Cappuccino, and Dojo, which tried to
abstract away HTML, most web developers began rejecting any solution whose
source code they couldn&amp;#39;t read over in an afternoon. The &amp;quot;microlibrary&amp;quot; frenzy
had hit full tilt.&lt;/p&gt;

&lt;p&gt;However, we knew that as web browsers became more and more powerful, these
simplistic abstractions wouldn&amp;#39;t scale up to the kind of apps that users would
begin to demand.&lt;/p&gt;

&lt;p&gt;We realized that helping developers grapple with the complexity of building
100% JavaScript web applications could only happen if we embraced the tools
that they were most comfortable with: HTML and CSS.&lt;/p&gt;

&lt;p&gt;Based on the current popularity of frameworks like Ember, Angular and Knockout,
it&amp;#39;s clear that this strategy turned out to be the right one.&lt;/p&gt;

&lt;p&gt;As we began work on Ember.js, however, we soon realized that there was a
fundamental problem. Just having templates that were bound to models was
not enough. We also needed to help developers decide &lt;em&gt;which&lt;/em&gt; templates and
models to display at any given time.&lt;/p&gt;

&lt;p&gt;While struggling to figure out the best solution, we couldn&amp;#39;t help but notice
that many JavaScript applications on the web felt broken. Basic things that
we had taken for granted for two decades all of a sudden stopped working.
Just clicking the browser&amp;#39;s back button was enough to break many of these apps.&lt;/p&gt;

&lt;p&gt;We realized that the solution to our problem had been sitting under our noses
all along: the URL is what web applications use to decide what to display!&lt;/p&gt;

&lt;p&gt;We knew that we had to go back to the drawing board. We rebooted the entire
project mid-course to refocus on how to build JavaScript apps that not only
helped you architect large, multi-page applications, but helped you to do so
without breaking the basic building blocks of the web.&lt;/p&gt;

&lt;p&gt;Over time, we&amp;#39;ve added even more features, like components, that help bring
solid UI architecture to the web. We are incredibly proud of the job that
the community has done to lay a solid foundation that we can build upon for the
years to come.&lt;/p&gt;

&lt;p&gt;This 1.0 release is a promise from us: the pain that many experienced while we
were figuring out how to build a JavaScript framework for the future of the web
is now over. In keeping with the Semantic Versioning spec, there will be no
more intentional breaking changes until we release Ember 2.0, which we don&amp;#39;t
anticipate happening for some time.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_recent-developments'&gt;Recent Developments&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_router-facelift'&gt;Router Facelift&lt;/h3&gt;
&lt;p&gt;Over the past few months, Alex Matchneer has taken the Ember router to the next
level. Alex&amp;#39;s changes focus on making the router an excellent tool for managing
complex asynchronous flows (like authentication), and you can learn all about it
in his recently completed guides:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/guides/routing/asynchronous-routing/"&gt;Asynchronous Routing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/guides/routing/preventing-and-retrying-transitions/"&gt;Preventing and Retrying Transitions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class='anchorable-toc' id='toc_preparation-for-modules'&gt;Preparation for Modules&lt;/h3&gt;
&lt;p&gt;In the years since we started Ember, the JavaScript module ecosystem has become
increasingly mature.&lt;/p&gt;

&lt;p&gt;Today, tools like &lt;a href="http://requirejs.org/"&gt;require.js&lt;/a&gt; and module systems like &lt;a href="https://github.com/amdjs/amdjs-api/wiki/AMD"&gt;AMD&lt;/a&gt;, &lt;a href="http://nodejs.org/api/modules.html"&gt;Node&lt;/a&gt;,
and &lt;a href="https://github.com/square/es6-module-transpiler"&gt;ES6 Modules&lt;/a&gt; continue to gain traction. Increasingly, people are using
named modules and module loaders rather than storing their code in globals.&lt;/p&gt;

&lt;p&gt;To prepare for this future, all of the code lookup and naming conventions in
Ember.js now go through a single &lt;code&gt;Resolver&lt;/code&gt;. The default &lt;code&gt;Resolver&lt;/code&gt; still looks
for code under global namespaces, but &lt;a href="https://github.com/stefanpenner/ember-app-kit/blob/master/vendor/loader.js#L41-L136"&gt;Ember App Kit&lt;/a&gt; already provides an
alternative resolver that looks for code in AMD modules.&lt;/p&gt;

&lt;p&gt;In the near future, we plan to roll in first-class support for modules into the
framework, based on the experiences of users of the increasingly popular Ember
App Kit.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-testing'&gt;Ember Testing&lt;/h3&gt;
&lt;p&gt;The Ember community has always been passionate about testing. Even at the earliest
meetups, testing was one of the most frequently asked-about topics, and testing
featured prominently in our thinking as we built out the new router.&lt;/p&gt;

&lt;p&gt;As we got closer to Ember 1.0, we realized that we needed to provide an official
set of testing-framework agnostic testing helpers. The Ember Testing
package is the start of a longer-term focus on testing facilities that we plan
to improve even more in the 1.x timeframe.&lt;/p&gt;

&lt;p&gt;You can see some of our thoughts for future improvements on the &lt;a href="http://discuss.emberjs.com/t/ember-testing-improvements/1652"&gt;Ember
Discussion Forum&lt;/a&gt;.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-inspector-for-chrome'&gt;Ember Inspector for Chrome&lt;/h3&gt;
&lt;p&gt;Teddy Zeenny&amp;#39;s relentless work on the Ember Inspector has been some of the most
awe-inspiring work we&amp;#39;ve seen in open source.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi"&gt;Ember Inspector&lt;/a&gt; that ships with Ember 1.0 makes it easy to see how an
Ember application is laid out, and presents all of the naming conventions in an easy-to-read table.
If you&amp;#39;re using Ember Data, it also lets you see all of the records that your application has loaded at
a glance.&lt;/p&gt;

&lt;p&gt;Coming up next is asynchronous debugging to help make sense of some of the more
quirky behavior of Promises.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://lh6.googleusercontent.com/TGLbr4UoyLqBNvZACqghquEMo5bVWWrlA8f_UkCf4F5etIcqNM0HcBLVRRCQHHLWwBilJbznxrk=s1280-h800-e365-rw"&gt;&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_performance-performance-performance'&gt;Performance, Performance, Performance&lt;/h3&gt;
&lt;p&gt;A number of community members, especially Kris Selden, Erik Bryn and Robin Ward
have done heroic work lately on performance.&lt;/p&gt;

&lt;p&gt;Over the years, Ember&amp;#39;s internals have been significantly sped up time and
time again, and we will continue to hone the performance of Ember going forward.&lt;/p&gt;

&lt;p&gt;In the 1.x timeframe, we have a number of ideas that should significantly
improve rendering performance and decrease the amount of GC during rendering,
so keep an eye out!&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_docs-docs-docs'&gt;Docs, Docs, Docs&lt;/h3&gt;
&lt;p&gt;The early lack of good documentation for Ember seriously pained us, as we&amp;#39;re all
big believers in the idea that user confusion should be considered a bug in the
framework.&lt;/p&gt;

&lt;p&gt;Over the past year, we&amp;#39;ve significantly improved both the &lt;a href="http://emberjs.com/api"&gt;API documentation&lt;/a&gt;
and the &lt;a href="http://emberjs.com/guides"&gt;Guides&lt;/a&gt;. Trek Glowacki has led up the effort, which has resulted in
comprehensive coverage of how to use Ember, an excellent, up-to-date Getting
Started Guide, and most recently, a Cookbook section for common scenarios.&lt;/p&gt;

&lt;p&gt;For Ember 1.0, Trek led a documentation audit of all of the API documentation in
the entire codebase, which led to 1,700 new lines of documentation, and an
across-the-board freshening for new idioms and best practices.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-data-1-0-beta-1'&gt;Ember Data 1.0 Beta 1&lt;/h3&gt;
&lt;p&gt;With the release of Ember 1.0, we&amp;#39;re glad to also release the first beta of
Ember Data 1.0.&lt;/p&gt;

&lt;p&gt;Ember Data 1.0 is a reboot of our data layer. The focus of the effort (codenamed
&lt;code&gt;jj-abrams&lt;/code&gt;, famous for franchise reboots) was:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A more flexible codebase, able to handle streaming, custom JSON, and edits
while saving with ease. If you&amp;#39;ve found Ember Data too inflexible for your
backend in the past, try it again!&lt;/li&gt;
&lt;li&gt;Asynchronous operations are now all backed by promises. This will integrate
better with Ember&amp;#39;s own asynchronous handling, and make it easier to combine
and pipeline asynchronous operations like &lt;code&gt;find&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Better support for modules. Ember.js itself now has good support for modules,
through Ember App Kit&amp;#39;s drop-in resolver, but Ember Data&amp;#39;s reliance on global
lookups (through &lt;code&gt;App.Post.find&lt;/code&gt;, etc.) made Ember Data hard to use with
modules. The Ember Data 1.0 API is much more friendly to modules, and
therefore the future of Ember.js and the web platform.&lt;/li&gt;
&lt;li&gt;Much better documentation of Ember Data&amp;#39;s APIs, including the adapter and
serializer APIs. Flexible APIs are no good if it&amp;#39;s impossible to learn about
them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;#39;re a current user of Ember Data, you may want to check out the
&lt;a href="https://github.com/emberjs/data/blob/master/TRANSITION.md"&gt;Transition Guide&lt;/a&gt;. If you have issues upgrading that aren&amp;#39;t covered in the
guide, please let us know right away so we can improve it.&lt;/p&gt;

&lt;p&gt;Note: If you aren&amp;#39;t ready to upgrade just yet, we&amp;#39;ve released Ember Data 0.14,
which includes a number of useful performance optimization for Ember Data 0.13
but no breaking changes.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_community'&gt;Community&lt;/h2&gt;
&lt;p&gt;The Ember community is amazing.&lt;/p&gt;

&lt;blockquote class="twitter-tweet"&gt;&lt;p&gt;I love the Ember community&lt;/p&gt;&amp;mdash; Yehuda Katz (@wycats) &lt;a href="https://twitter.com/wycats/statuses/372760498187427841"&gt;August 28, 2013&lt;/a&gt;&lt;/blockquote&gt;

&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;

&lt;p&gt;In addition to the insane amount of work that members of the Ember community
have been doing to prepare the Ember 1.0 release, the community has also been
churning out a number of awesome Ember-related projects.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/stefanpenner/ember-app-kit"&gt;Ember App Kit&lt;/a&gt;: An effort by a number of members of the Ember community
to work on tooling for Ember that will eventually become the core of official
Ember tools.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rpflorence/ember-tools"&gt;Ember Tools&lt;/a&gt;: Similar work by Ryan Florence, which will be merged into Ember
App Kit as we begin to bring tooling into core.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ember-addons.github.io/bootstrap-for-ember/dist/"&gt;Bootstrap for Ember&lt;/a&gt;: Twitter Bootstrap wrapped in Ember components!&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/billysbilling/ember-animated-outlet"&gt;Ember Animated Outlet&lt;/a&gt;: Support for animated &lt;code&gt;{{outlet}}&lt;/code&gt;s and
&lt;code&gt;{{link-to}}&lt;/code&gt; on top of the current Ember by Sebastian Seilund of Billy&amp;#39;s
Billings.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://adminjs.com/"&gt;Admin.js&lt;/a&gt;: An awesome, flexible and configurable admin for your site
written in Ember by Gordon Hempton. You can use it with an Ember app or just
to provide an admin interface for your Rails, Django, PHP, or whatever app!&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberhotseat.com/"&gt;The Ember Hot Seat&lt;/a&gt;: A regular podcast brought to you by DeVaris Brown.
It regularly features members of the Ember Core Team and prominent members of
the Ember community.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/EmberWatch"&gt;EmberWatch&lt;/a&gt;: Philip Poot&amp;#39;s EmberWatch Twitter account and website will
keep you up-to-date on the latest projects and news.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberweekly.com/"&gt;Ember Weekly&lt;/a&gt;: Ember Weekly, curated by the inimitable Owain
Williams, packs all the Ember news that&amp;#39;s fit to print into your inbox
every week.&lt;/li&gt;
&lt;li&gt;And way more projects. Keep an eye out on this blog, or follow us on the
official @emberjs Twitter account. We plan to feature more projects like these
in the future.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;#39;ve also been grateful to be the beneficiary of large amounts of support from
a number of companies over the years.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LivingSocial, which funded much of the original work on Ember Data.&lt;/li&gt;
&lt;li&gt;Yapp, whose employees have been working on Ember (and SproutCore before
Ember) for years, and which has dedicated countless man-hours to making Ember
better.&lt;/li&gt;
&lt;li&gt;Zendesk, an early user and contributor to Ember. Thank you for betting on
Ember as early as you did.&lt;/li&gt;
&lt;li&gt;McGraw-Hill Education Labs, which has been funding Ember work for over a year,
with great patience, resolve and vision.&lt;/li&gt;
&lt;li&gt;Tilde, which employs Tom, Yehuda, Peter and Leah, and which handles much of
the (unseen) administrative work of the project.&lt;/li&gt;
&lt;li&gt;Billy&amp;#39;s Billings, which has given Sebastian Selund time to work on Ember, and
hosted the work on &lt;code&gt;ember-animated-outlet&lt;/code&gt;, which will make its way into a
future version of Ember.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, a number of large open source projects have bet on Ember. These
projects contribute significantly to Ember&amp;#39;s development, and also give Ember
users a place to look at large, real-world projects.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt;: A very early Ember adopter. The Ember project makes heavy use of
Travis, so thank you!&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.discourse.org/"&gt;Discourse&lt;/a&gt;: The increasingly popular forum engine that now powers
TalkingPointsMemo and BoingBoing. These guys have contributed heavily to Ember
and its community.&lt;/li&gt;
&lt;li&gt;Balanced: Balanced is an &lt;a href="https://github.com/balanced"&gt;open-source&lt;/a&gt;, &lt;strong&gt;open company&lt;/strong&gt;. They use Ember
for their &lt;a href="https://github.com/balanced/balanced-dashboard"&gt;dashboard&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class='anchorable-toc' id='toc_undefined-semantics'&gt;Undefined Semantics&lt;/h2&gt;
&lt;p&gt;There are two areas of Ember.js that have semantics that may accidentally work
in some cases today, but are the source of a number of bugs, and which we don&amp;#39;t
plan to support in the future.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_observer-timing'&gt;Observer Timing&lt;/h3&gt;
&lt;p&gt;At present, Ember observers sometimes fire synchronously, but sometimes fire
asynchronously. The only thing your code should rely on is that the observer
will fire &lt;strong&gt;after&lt;/strong&gt; the property it observes has changed.&lt;/p&gt;

&lt;p&gt;We plan to bring all observers into alignment with &lt;a href="http://wiki.ecmascript.org/doku.php?id=harmony:observe"&gt;Object.observe&lt;/a&gt;, a
future JavaScript feature. In the future, observers will &lt;strong&gt;never&lt;/strong&gt; fire
synchronously. If you rely on specific timing, your code may break.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_observing-properties-of-framework-objects'&gt;Observing Properties of Framework Objects&lt;/h3&gt;
&lt;p&gt;In general, you should not observe properties of framework objects defined by
the framework that are not explicitly documented as observable. Some of these
observations may happen to work today, but may not work in the future.&lt;/p&gt;

&lt;p&gt;For example, you should not observe the &lt;code&gt;element&lt;/code&gt; property on an Ember view or
component. Instead, you should use the &lt;code&gt;didInsertElement&lt;/code&gt; hook.&lt;/p&gt;

&lt;p&gt;If you find yourself observing a framework-defined property that is not
documented as observable to work around an issue, &lt;strong&gt;please&lt;/strong&gt; file an issue with
us so we can give you a publicly defined API.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_the-future'&gt;The Future&lt;/h2&gt;
&lt;p&gt;Despite our commitment to stability, we are not resting on our laurels. We have
an aggressive pipeline of new features planned, which we&amp;#39;ll be announcing soon.&lt;/p&gt;

&lt;p&gt;We&amp;#39;re also switching our releases to follow a more Chrome-like model. This means
that you can expect a new release every six weeks. We&amp;#39;ll have more details about
this soon.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_thanks'&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Special thanks to a number of community members who have done heroic work
leading up to Ember 1.0:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Eric Berry, for the new Cookbook section in the guides and examples&lt;/li&gt;
&lt;li&gt;Paul Chavard, for help reviewing Ember Data 1.0 Beta 1&lt;/li&gt;
&lt;li&gt;Domenic Denicola, for putting us on the right path with promises&lt;/li&gt;
&lt;li&gt;Dan Gebhardt, for website infrastructure&lt;/li&gt;
&lt;li&gt;David Hamilton, for the Array Computed feature&lt;/li&gt;
&lt;li&gt;Robert Jackson, for the new emberjs.com/builds&lt;/li&gt;
&lt;li&gt;Julien Knebel, for design work&lt;/li&gt;
&lt;li&gt;Alex Matchneer, for the async router guide&lt;/li&gt;
&lt;li&gt;Luke Melia, for &lt;code&gt;actions&lt;/code&gt; namespacing, last minute bugfix work, and the Ember NYC community&lt;/li&gt;
&lt;li&gt;Alex Navasardyan, for inline examples on the homepage and design work&lt;/li&gt;
&lt;li&gt;Stanley Stuart, for testing infrastructure&lt;/li&gt;
&lt;li&gt;Igor Terzic, for help reviewing Ember Data 1.0 Beta 1&lt;/li&gt;
&lt;li&gt;Teddy Zeenny, for the Ember Inspector&lt;/li&gt;
&lt;li&gt;The 300 people who submitted code and documentation to Ember 1.0&lt;/li&gt;
&lt;li&gt;The 131 people who submitted code and documentation to Ember Data 1.0 Beta 1&lt;/li&gt;
&lt;li&gt;The 269 people who helped with &lt;a href="http://emberjs.com"&gt;emberjs.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go forth and build great things!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember 1.0 RC8发布</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2013/08/28/ember-1-0-rc8.html"/>
    <id>http://emberjs.cn/blog/2013/08/28/ember-1-0-rc8.html</id>
    <published>2013-08-28T00:00:00Z</published>
    <updated>2013-08-28T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;Ember 1.0 RC8是1.0正式版前的最后一次发布，如果一切顺利本周末将发布Ember
1.0正式版。&lt;/p&gt;

&lt;p&gt;在RC8中做了一些1.0正式版之前的重大更改，这些更改对应用代码只有很少的影响，不过带来了很大的性能提升。&lt;/p&gt;

&lt;p&gt;这些更改都与观察器有关。如果编码的时候使用了大量的观察器，那么可能意味着代码不符合语言习惯。通常只在与其他不支持绑定机制的库桥接的时候需要使用观察器。&lt;/p&gt;

&lt;p&gt;例如，如果编写一个包裹jQuery
UI控件的组件时，可能需要使用观察器来监视组件上的改变，并将这些改变反映到控件上。&lt;/p&gt;

&lt;p&gt;在应用代码中，应该尽可能的使用计算属性。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;Ember 1.0 RC8是1.0正式版前的最后一次发布，如果一切顺利本周末将发布Ember
1.0正式版。&lt;/p&gt;

&lt;p&gt;在RC8中做了一些1.0正式版之前的重大更改，这些更改对应用代码只有很少的影响，不过带来了很大的性能提升。&lt;/p&gt;

&lt;p&gt;这些更改都与观察器有关。如果编码的时候使用了大量的观察器，那么可能意味着代码不符合语言习惯。通常只在与其他不支持绑定机制的库桥接的时候需要使用观察器。&lt;/p&gt;

&lt;p&gt;例如，如果编写一个包裹jQuery
UI控件的组件时，可能需要使用观察器来监视组件上的改变，并将这些改变反映到控件上。&lt;/p&gt;

&lt;p&gt;在应用代码中，应该尽可能的使用计算属性。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;声明事件监听器&lt;/h4&gt;
&lt;p&gt;现在Ember提供了一种方法来用声明的方式给Ember类添加事件监听器。这比手动在&lt;code&gt;init&lt;/code&gt;中设置监听器要简单很多。&lt;/p&gt;

&lt;p&gt;以前的方法：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = DS.Model.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;didLoad&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="local-variable"&gt;this&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;() {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.finishedLoading();
    });
  },

  &lt;span class="function"&gt;finishedLoading&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// do stuff&lt;/span&gt;
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在只需要：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = DS.Model.extend({
  &lt;span class="function"&gt;finishedLoading&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// do stuff&lt;/span&gt;
  }.on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;didLoad&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;数组计算&lt;/h4&gt;
&lt;p&gt;现在有一种符合惯例和稳定的方法来构建一个基于数组的计算属性，其将只对更新的部分进行计算。&lt;/p&gt;

&lt;p&gt;例如，当有一组people时，并想通过一个计算属性返回他们的年龄。&lt;/p&gt;

&lt;p&gt;当前最简单的实现方法是：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;childAges&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).mapBy(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children.@each.age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样实现非常简洁，但是当数组中任何时候有一个元素被添加或者删除时，就会重新计算整个数组。对于小的数组来说，这可能不成问题。然而，如果数组非常巨大，或者这些计算属性被链式使用，或者用于完成一些繁重的工作，那么开销将会非常大。&lt;/p&gt;

&lt;p&gt;这时可以使用数组计算属性性：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;childAges&lt;/span&gt;: Ember.computed.mapBy(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以将数组计算属性链接在一起：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;childAges&lt;/span&gt;: Ember.computed.mapBy(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),
  &lt;span class="key"&gt;maxChildAge&lt;/span&gt;: Ember.computed.max(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;childAges&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当一个元素被添加或者删除时，计算只进行一次。在本例中，如果添加一个孩子，那他的年龄会被追加到&lt;code&gt;childAges&lt;/code&gt;中，并且如果这个年龄大于&lt;code&gt;maxChildAge&lt;/code&gt;，那么&lt;code&gt;maxChildAge&lt;/code&gt;也将得到更新。&lt;/p&gt;

&lt;p&gt;这些计算属性总是保持同步、高效，并完全由Ember来管理。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_ember'&gt;Ember扩展&lt;/h4&gt;
&lt;p&gt;经过几个月的测试，及Teddy Zeenny的辛勤付出，Ember
Inspector已经准备发布到Chrome Web Store了。&lt;/p&gt;

&lt;p&gt;最近，Teddy添加了对加载的数据的支持。已经支持Ember Data，Ember
Model的支持也在开发中。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-ember-data.png"&gt;&lt;/p&gt;

&lt;p&gt;Teddy完成了对象检查器的重大改进，增加了对组属性对象的支持（如：Ember
Data模型的属性、一对多关联），支持通过检查器修改对象。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-editing.png"&gt;&lt;/p&gt;

&lt;p&gt;通过检查器可以查看应用中所有路由的列表，这些命名可以与对象结合使用。这样更容易记住命名惯例。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-routes.png"&gt;&lt;/p&gt;

&lt;p&gt;另外，视图树通过应用模板关联的控制器和模型显示了应用的概况。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-view-tree.png"&gt;&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;其他改进&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;改进&lt;code&gt;yield&lt;/code&gt;，确保其总是&lt;code&gt;yield&lt;/code&gt;回调用的上下文。&lt;/li&gt;
&lt;li&gt;不使用W3C range API来改进range更新的性能&lt;/li&gt;
&lt;li&gt;完成1.0文档的审查&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;重复定义同名的模板时给出更加友好的错误消息&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;ApplicationController&lt;/code&gt;中添加&lt;code&gt;currentRouteName&lt;/code&gt;，可以用于&lt;code&gt;link-to&lt;/code&gt;和&lt;code&gt;transitionTo&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;定义新的别名：&lt;code&gt;linkTo&lt;/code&gt; -&amp;gt; &lt;code&gt;link-to&lt;/code&gt;，&lt;code&gt;bindAttr&lt;/code&gt; -&amp;gt; &lt;code&gt;bind-attr&lt;/code&gt;，来保持与html命名一致。老命名还保留不过已经软废除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_tl-dr'&gt;更新 TL;DR&lt;/h4&gt;&lt;h5 class='anchorable-toc' id='toc_'&gt;观察器在构造过程中不触发&lt;/h5&gt;
&lt;p&gt;以前通过&lt;code&gt;create&lt;/code&gt;传入或者在prototype上指定的属性不会触发观察器，但在&lt;code&gt;init&lt;/code&gt;中通过&lt;code&gt;set&lt;/code&gt;方法设置的属性会触发。&lt;/p&gt;

&lt;p&gt;现在观察器直到&lt;code&gt;init&lt;/code&gt;完后才会触发观察器。&lt;/p&gt;

&lt;p&gt;如果在初始化过程中需要出发一个观察器，不能通过&lt;code&gt;set&lt;/code&gt;来实现，需要在观察器上通过&lt;code&gt;.on(&amp;#39;init&amp;#39;)&lt;/code&gt;指定其在&lt;code&gt;init&lt;/code&gt;下也工作。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;salutation&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Mr/Ms&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
  },

  &lt;span class="function"&gt;salutationDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// some side effect of salutation changing&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;salutation&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;init&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h5 class='anchorable-toc' id='toc_'&gt;没有消费的计算属性不触发观察器&lt;/h5&gt;
&lt;p&gt;如果从未&lt;code&gt;get&lt;/code&gt;一个计算属性，与它相关的观察器不会被触发，即使其依赖的键已经改变。可以想象为值从一个未知的值变成了另一个。&lt;/p&gt;

&lt;p&gt;这基本上不会影响到应用程序代码，因为计算属性几乎总是在其取来的时候同时被观察到。例如，获取一个计算属性的值，将其放置到DOM中，（或者通过D3绘图），接着观察它，以便在其更新的时候更新DOM。&lt;/p&gt;

&lt;p&gt;如果需要观察一个不需要立即使用的计算属性，可以在&lt;code&gt;init&lt;/code&gt;方法中&lt;code&gt;get&lt;/code&gt;它一下。&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_'&gt;路由、控制器和视图的新操作哈希&lt;/h5&gt;
&lt;p&gt;为了保持一致性并提供更灵活的操作命名，通过一个统一的&lt;code&gt;actions&lt;/code&gt;哈希来定义操作。当继承一个定义了&lt;code&gt;actions&lt;/code&gt;的类时，会在子类将定义的&lt;code&gt;actions&lt;/code&gt;进行合并，或在父进行实例化。另外还支持&lt;code&gt;_super&lt;/code&gt;，因此没有散失任何的灵活性。&lt;/p&gt;

&lt;p&gt;之前的行为依然支持，不过已经废除了。如果一个控制器代理了一个拥有&lt;code&gt;actions&lt;/code&gt;属性的模型，那么将自动将其重命名为&lt;code&gt;_actions&lt;/code&gt;来避免发生任何可能的冲突。&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_handlebars'&gt;在Handlebars助手中使用引号引起来的字符串&lt;/h5&gt;
&lt;p&gt;过去，Handlebars助手没有严格限制字符串是否需要加引号。不幸的是，这意味着没有办法区分字符串值和属性路径。现在严格限制如果希望是一个字符串值的话，必须加引号。这意味着&lt;code&gt;link-to&lt;/code&gt;的路由名必须用引号引起来。相反，如果定义一个自定义的绑定助手，并且用一个引号引起来的字符表示属性路径，这将不再工作。加引号表示字符串，不加表示路径。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_code-init-code'&gt;在&lt;code&gt;init&lt;/code&gt;中设置属性&lt;/h4&gt;
&lt;p&gt;当前，传递一个哈希给&lt;code&gt;create&lt;/code&gt;和在&lt;code&gt;init&lt;/code&gt;中设置同样的属性是不一致的。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// this observer does not fire&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});

App.Person.create({ &lt;span class="key"&gt;firstName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tom&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Dale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;本例中，由于所有属性都是通过一个传给&lt;code&gt;create&lt;/code&gt;的hash来设置的，观察器不会被触发。&lt;/p&gt;

&lt;p&gt;下面看一看在RC7中在&lt;code&gt;init&lt;/code&gt;方法里完成同样的出发会发生什么：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR&lt;/span&gt;

App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;if&lt;/span&gt; (!&lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)) {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tom&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
    }
  },
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// this observer fires&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});

App.Person.create({ &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Dale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在此，如果&lt;code&gt;firstName&lt;/code&gt;没有，也会出发观察器。&lt;/p&gt;

&lt;p&gt;新的设计对象模型只在构造后会触发观察器，这是为什么&lt;code&gt;create&lt;/code&gt;不触发的原因。&lt;/p&gt;

&lt;p&gt;此外，因为如果为包含数组、对象值的属性进行初始化只能在&lt;code&gt;init&lt;/code&gt;中，这导致了不一致性：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR&lt;/span&gt;

App.Person = Ember.Object.extend({
  &lt;span class="comment"&gt;// initial property value, does not trigger an initialization observer&lt;/span&gt;
  &lt;span class="key"&gt;salutation&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Mr.&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,

  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// also initial property value, triggers an observer on&lt;/span&gt;
    &lt;span class="comment"&gt;// initialization&lt;/span&gt;
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, []);
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;总之，属性在初始化过程中被设置不论是否设置到prototype，或作为哈希传给&lt;code&gt;create&lt;/code&gt;，或在&lt;code&gt;init&lt;/code&gt;中被设置，都不触发观察器。&lt;/p&gt;

&lt;p&gt;如果有代码需要不论是在初始化过程还是当一个属性改变时执行，必须使用&lt;code&gt;.on(&amp;#39;init&amp;#39;)&lt;/code&gt;将其标记为需要在初始化过程执行。这种情况最好是进行重构，来避免&lt;code&gt;init&lt;/code&gt;时&lt;code&gt;set&lt;/code&gt;的负面效应。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// some side effect that happens when first name changes&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;init&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;计算属性性能改进&lt;/h4&gt;
&lt;p&gt;最新发布的Ember.js版本包含了观察器和计算属性交互的更新。这对依赖旧有行为的应用是一个破坏性的更新。&lt;/p&gt;

&lt;p&gt;为了理解这个更新，通过一个计算属性的例子来介绍。假设尝试用Ember.js对象来为&lt;a href="http://en.wikipedia.org/wiki/Schr%C3%B6dinger&amp;#x27;s_cat"&gt;Schrödinger&amp;#39;s famous cat&lt;/a&gt; 建模。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Cat = Ember.Object.extend({
  &lt;span class="function"&gt;isDead&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; Math.rand() &amp;gt; &lt;span class="float"&gt;0.5&lt;/span&gt;;
  }.property()
});

&lt;span class="keyword"&gt;var&lt;/span&gt; cat = App.Cat.create();
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;给定一个猫的对象，判断猫是死是活？这里通过一个随机数来决定。在观察猫对象之前，可以说猫既是死的又是活的，或者要死不活。&lt;/p&gt;

&lt;p&gt;而实际上，并非猫超凡脱俗，而是取决于第一次调用。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;cat.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;isDead&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class="comment"&gt;// true&lt;/span&gt;
&lt;span class="comment"&gt;// …or false, half the time&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在询问了猫对象的&lt;code&gt;isDead&lt;/code&gt;属性后，就可以明确的说猫是死还是活。但是在此之前，这个计算属性的值并不存在。&lt;/p&gt;

&lt;p&gt;下面看看在混合（Mix）中的观察器。如果计算属性的值还不存在，其依赖的键发生改变时是否触发观察器？&lt;/p&gt;

&lt;p&gt;在之前版本的Ember.js中，答案是肯定的。例如：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;observerCount&lt;/span&gt;: &lt;span class="integer"&gt;0&lt;/span&gt;,

  &lt;span class="function"&gt;fullName&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),

  &lt;span class="function"&gt;fullNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.incrementProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;依赖的任意键发生改变，都会触发观察者：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR DO NOT RELY ON THIS&lt;/span&gt;

&lt;span class="keyword"&gt;var&lt;/span&gt; person = App.Person.create({
  &lt;span class="key"&gt;firstName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Yehuda&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Katz&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
});

person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 0&lt;/span&gt;

person.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tomhuda&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 1&lt;/span&gt;

person.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Katzdale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后，因为&lt;code&gt;fullName&lt;/code&gt;属性并不&amp;quot;exist&amp;quot;直到请求它为止，触发一个观察者是否是正确的行为并不明确。&lt;/p&gt;

&lt;p&gt;一个影响计算属性的关联问题是如果计算属性依赖键包含一个路径。（请记住依赖键只是定义一个计算属性时，传递个&lt;code&gt;.property()&lt;/code&gt;方法的属性名。&lt;/p&gt;

&lt;p&gt;例如，假设构造一个模型表示一篇博客，如果需要使用博客的评论，采用延迟加载的方式加载评论（例如在模板中）。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.BlogPost = Ember.Object.extend({
  &lt;span class="function"&gt;comments&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;var&lt;/span&gt; comments = [];
    &lt;span class="keyword"&gt;var&lt;/span&gt; url = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/post/&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/comments.json&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);

    &lt;span class="predefined"&gt;$&lt;/span&gt;.getJSON(url).then(&lt;span class="keyword"&gt;function&lt;/span&gt;(data) {
      data.forEach(&lt;span class="keyword"&gt;function&lt;/span&gt;(comment) {
        comments.pushObject(comment);
      });
    });

    &lt;span class="keyword"&gt;return&lt;/span&gt; comments;
  }.property()
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在这里跟预期的行为一样，博文的评论只会在第一次使用&lt;code&gt;post.get(&amp;#39;comments&amp;#39;)&lt;/code&gt;或者在模板中使用的时候，才通过网络去加载：&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt; &lt;span class="attribute-name"&gt;comments&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;title&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然而，现在希望添加一个计算属性，用来从加载的评论中选择第一条：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.BlogPost = Ember.Object.extend({
  &lt;span class="function"&gt;comments&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;var&lt;/span&gt; comments = [];
    &lt;span class="keyword"&gt;var&lt;/span&gt; url = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/post/&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/comments.json&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;

    &lt;span class="predefined"&gt;$&lt;/span&gt;.getJSON(url).then(&lt;span class="keyword"&gt;function&lt;/span&gt;(data) {
      data.forEach(&lt;span class="keyword"&gt;function&lt;/span&gt;(comment) {
        comments.pushObject(comment);
      });
    });

    &lt;span class="keyword"&gt;return&lt;/span&gt; comments;
  }.property(),

  &lt;span class="function"&gt;firstComment&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comments.firstObject&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comments.firstObject&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在有了一个问题！因为&lt;code&gt;firstComment&lt;/code&gt;计算属性依赖&lt;code&gt;comments.firstObject&lt;/code&gt;，为了建立一个&lt;code&gt;firstObject&lt;/code&gt;的观察器，它将&lt;code&gt;get()&lt;/code&gt;&lt;code&gt;comments&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;在此添加这个计算属性意味着应用中所有博文的评论都被加载，无论评论是否被使用！&lt;/p&gt;

&lt;p&gt;为了决定如何处理，花了一些时间分析实际的Ember.js应用。发现这个行为严重的影响了性能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;触发没有物化的计算属性的观察器意味着需要在一开始的时候为所有计算属性设置监听器，而不是在第一次计算的时候。&lt;/li&gt;
&lt;li&gt;许多计算属性因为路径依赖键，从未使用，也未被计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了修正这些问题，&lt;strong&gt;RC8做了一下改变&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;观察一个计算属性的观察器只在该属性被使用过至少一次后才会被触发。&lt;/li&gt;
&lt;li&gt;观察一个路径（&lt;code&gt;&amp;quot;foo.bar.baz&amp;quot;&lt;/code&gt;），或者使用一个路径作为一个依赖主键，将不导致路径任意部分从未计算变为计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大部分Ember.js应用程序不会受此影响，因为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;大部分应用程序观察计算属性，并且在对象初始化时就&lt;code&gt;get()&lt;/code&gt;这些属性，因而触发了正确的行为。&lt;/li&gt;
&lt;li&gt;对于计算属性依赖键，新行为正是开发者所期待的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果应用受这个更改的影响，修正方法非常简单，只需要在类的&lt;code&gt;init&lt;/code&gt;方法中&lt;code&gt;get()&lt;/code&gt;计算属性即可。&lt;/p&gt;

&lt;p&gt;例如，为了更新上述的观察器例子，能通过&amp;quot;precomputing&amp;quot;&lt;code&gt;fullName&lt;/code&gt;属性来保持RC8之前版本的行为：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
    &lt;span class="local-variable"&gt;this&lt;/span&gt;._super();
  },

  &lt;span class="key"&gt;observerCount&lt;/span&gt;: &lt;span class="integer"&gt;0&lt;/span&gt;,

  &lt;span class="function"&gt;fullName&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),

  &lt;span class="function"&gt;fullNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.incrementProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_code-link-to-code'&gt;&lt;code&gt;link-to&lt;/code&gt;绑定参数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;link-to&lt;/code&gt;助手（之前为&lt;code&gt;linkTo&lt;/code&gt;）现在将未加引号的参数（非数字参数）作为绑定属性路径对待，这意味着当一个传给&lt;code&gt;link-to&lt;/code&gt;的属性改变时，链接的&lt;code&gt;href&lt;/code&gt;将改变。这包括第一个参数（目标路由名）和接着的任意上下文参数。&lt;/p&gt;

&lt;p&gt;下面的模板例子将在当前上下文（通常是一个控制器）查找&lt;code&gt;destinationRoute&lt;/code&gt;，并使用其来决定链接的&lt;code&gt;href&lt;/code&gt;和点击链接将切换至的路由。&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt; &lt;span class="attribute-name"&gt;destinationRoute&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;Link Text&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面的例子将一直指向&lt;code&gt;articles.show&lt;/code&gt;路由（因为路由名称参数加了引号），但是当&lt;code&gt;article&lt;/code&gt;的值改变时，链接的&lt;code&gt;href&lt;/code&gt;将更新为对应&lt;code&gt;article&lt;/code&gt;新值的URL。&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt; &lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="attribute-name"&gt;articles.show&lt;/span&gt;&lt;span class="error"&gt;'&lt;/span&gt; &lt;span class="attribute-name"&gt;article&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;Read More...&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果之前写的应用没有正确的区分加引号的字符串和属性路径，这可能导致一些问题。因此当升级到RC8时，需要确定所有&lt;code&gt;link-to&lt;/code&gt;参数的静态字符串都正确的添加了引号。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;绑定助手：加引号的字符串，数字和路径&lt;/h4&gt;
&lt;p&gt;调用自定义的绑定助手（如通过&lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;定义的）时传入加引号的字符串或者原生数字会将其原值直接传入，而不是将所有的都作为绑定属性的路径，每次在属性变化的时候都重新渲染助手。&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Pass the string 'hello' to myHelper:
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;myHelper&lt;/span&gt; &lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="attribute-name"&gt;hello&lt;/span&gt;&lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;

Pass the property pointed-to by the path 'hello' to myHelper:
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;myHelper&lt;/span&gt; &lt;span class="attribute-name"&gt;hello&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果之前调用绑定助手时传入加引号的字符串，并期望其是一个绑定属性路径，那么会导致应用出现一些问题。因此需要确定只有当确实需要传入一个字符串的时候才给参数加引号，而不是路径对应的值。
如果之前写的应用没有正确的区分加引号的字符串和属性路径，这可能导致一些问题。因此当升级到RC8时，需要确定所有&lt;code&gt;link-to&lt;/code&gt;参数的静态字符串都正确的添加了引号。&lt;/p&gt;
</content>
  </entry>
</feed>
