<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EmberJS.CN Blog</title>
  <subtitle>Ember JS相关新闻与资源</subtitle>
  <id>http://emberjs.cn/blog</id>
  <link href="http://emberjs.cn/blog"/>
  <link href="http://emberjs.cn/blog/feed.xml" rel="self"/>
  <updated>2014-03-30T00:00:00Z</updated>
  <author>
    <name>EmberJS.CN</name>
  </author>
  <entry>
    <title>Ember 1.5.0和1.6 Beta发布</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2014/03/30/ember-1-5-0-and-ember-1-6-beta-released.html"/>
    <id>http://emberjs.cn/blog/2014/03/30/ember-1-5-0-and-ember-1-6-beta-released.html</id>
    <published>2014-03-30T00:00:00Z</published>
    <updated>2014-03-30T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;h3 class="anchorable-toc" id="toc_1-5"&gt;1.5中得新特性&lt;/h3&gt;&lt;h4 class="anchorable-toc" id="toc_handlebars"&gt;Handlebars记录原生值&lt;/h4&gt;
&lt;p&gt;本特性允许在模板中&lt;code&gt;log&lt;/code&gt;原生数据类型的值（字符串、数字等）&lt;/p&gt;
&lt;div class="highlight javascript "&gt;
&lt;div class="ribbon"&gt;&lt;/div&gt;
&lt;div class="scroller"&gt;
&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{log &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;**LOOKEY HERE**&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 class="anchorable-toc" id="toc_"&gt;新测试助手&lt;/h4&gt;&lt;h5 class="anchorable-toc" id="toc_"&gt;路由助手&lt;/h5&gt;
&lt;p&gt;添加了一些新的测试助手，以便可以方便的断言应用的路由所处的状态（例如点击一个链接后重定向到一个指定的路由）。&lt;/p&gt;

&lt;p&gt;新测试助手包括：&lt;code&gt;currentRouteName&lt;/code&gt;，&lt;code&gt;currentPath&lt;/code&gt;和&lt;code&gt;currentURL&lt;/code&gt;。&lt;/p&gt;
&lt;h5 class="anchorable-toc" id="toc_"&gt;触发事件助手&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;triggerEvent&lt;/code&gt;助手可以用于在一个元素上触发任意的事件。&lt;/p&gt;
&lt;div class="highlight javascript "&gt;
&lt;div class="ribbon"&gt;&lt;/div&gt;
&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
 ...&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;</summary>
    <content type="html">&lt;h3 class='anchorable-toc' id='toc_1-5'&gt;1.5中得新特性&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_handlebars'&gt;Handlebars记录原生值&lt;/h4&gt;
&lt;p&gt;本特性允许在模板中&lt;code&gt;log&lt;/code&gt;原生数据类型的值（字符串、数字等）&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{log &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;**LOOKEY HERE**&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;新测试助手&lt;/h4&gt;&lt;h5 class='anchorable-toc' id='toc_'&gt;路由助手&lt;/h5&gt;
&lt;p&gt;添加了一些新的测试助手，以便可以方便的断言应用的路由所处的状态（例如点击一个链接后重定向到一个指定的路由）。&lt;/p&gt;

&lt;p&gt;新测试助手包括：&lt;code&gt;currentRouteName&lt;/code&gt;，&lt;code&gt;currentPath&lt;/code&gt;和&lt;code&gt;currentURL&lt;/code&gt;。&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_'&gt;触发事件助手&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;triggerEvent&lt;/code&gt;助手可以用于在一个元素上触发任意的事件。&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;triggerEvent(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;#some-element-id&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;dblclick&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_ember-computed-readonly'&gt;Ember.computed.readOnly&lt;/h4&gt;
&lt;p&gt;通常当使用&lt;code&gt;Ember.computed.oneWay&lt;/code&gt;时，需要使用&lt;code&gt;readOnly&lt;/code&gt;来确保数据存在备份。&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// prior to Ember.computed.readOnly you would have to do the following:&lt;/span&gt;
Ember.computed.oneWay(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;foo&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).readOnly()

&lt;span class="comment"&gt;// in 1.5 you can use the following for the same result:&lt;/span&gt;
Ember.computed.readOnly(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;foo&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_ember-isblank'&gt;Ember.isBlank&lt;/h4&gt;
&lt;p&gt;用于检查一个特定的对象为空，或者为一个空的字符串：&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Ember.isBlank();                &lt;span class="comment"&gt;// true&lt;/span&gt;
Ember.isBlank(&lt;span class="predefined-constant"&gt;null&lt;/span&gt;);            &lt;span class="comment"&gt;// true&lt;/span&gt;
Ember.isBlank(&lt;span class="predefined-constant"&gt;undefined&lt;/span&gt;);       &lt;span class="comment"&gt;// true&lt;/span&gt;
Ember.isBlank(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);              &lt;span class="comment"&gt;// true&lt;/span&gt;
Ember.isBlank([]);              &lt;span class="comment"&gt;// true&lt;/span&gt;
Ember.isBlank(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;\n&lt;/span&gt;&lt;span class="content"&gt;\t&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);          &lt;span class="comment"&gt;// true&lt;/span&gt;
Ember.isBlank(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;  &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);            &lt;span class="comment"&gt;// true&lt;/span&gt;
Ember.isBlank({});              &lt;span class="comment"&gt;// false&lt;/span&gt;
Ember.isBlank(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;\n&lt;/span&gt;&lt;span class="content"&gt;\t&lt;/span&gt;&lt;span class="content"&gt; Hello&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);    &lt;span class="comment"&gt;// false&lt;/span&gt;
Ember.isBlank(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Hello world&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);   &lt;span class="comment"&gt;// false&lt;/span&gt;
Ember.isBlank([&lt;span class="integer"&gt;1&lt;/span&gt;,&lt;span class="integer"&gt;2&lt;/span&gt;,&lt;span class="integer"&gt;3&lt;/span&gt;]);         &lt;span class="comment"&gt;// false&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_url'&gt;渴望型更新URL&lt;/h4&gt;
&lt;p&gt;之前，地址栏中的URL只会在过渡的最后才会被更新。目前只要过渡没有在同一个运行循环中被取消/重定向，那么URL会被立即更新，这样99%的用户体验问题得到改善。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;自动定位&lt;/h4&gt;
&lt;p&gt;为应用的&lt;code&gt;Router&lt;/code&gt;的&lt;code&gt;location&lt;/code&gt;属性添加一个&lt;code&gt;auto&lt;/code&gt;选项。&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Router.reopen({
  &lt;span class="key"&gt;location&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;auto&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果使用了改选项，那么Ember会更具浏览器的支持按照：history，hash和none的顺序来选择最合适的定位方法。&lt;/p&gt;

&lt;p&gt;对于被只支持hash改变的浏览器的清理&lt;code&gt;pushState&lt;/code&gt;路径，会被重定向到与hash等价的方式，反之亦然。因此过渡保持了一致性。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;绑定操作查找&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;{{action}}&lt;/code&gt;助手可以使用无引号的参数，并在事件被触发时，在对应的操作目标对象的属性中区找这个参数绑定的属性。这样可以使用动态的操作名（通过属性获取操作的名称）。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_routes'&gt;Routes继承模型&lt;/h4&gt;
&lt;p&gt;Ember路由及叶子节点资源（没有嵌套的路由）将继承父路由的模型。&lt;/p&gt;

&lt;p&gt;如下下例所示：&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Router.map(&lt;span class="keyword"&gt;function&lt;/span&gt;(){
  &lt;span class="local-variable"&gt;this&lt;/span&gt;.resource(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.route(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;edit&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  });
});

App.PostRoute = Ember.Route.extend({
  &lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    &lt;span class="keyword"&gt;return&lt;/span&gt; {&lt;span class="key"&gt;title&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;ZOMG&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;text&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;AWESOME&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;};
  }
});

App.PostEditRoute = Ember.Route.extend({
  &lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.modelFor(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在1.5版本中，不在需要为&lt;code&gt;PostEditRoute&lt;/code&gt;定义&lt;code&gt;model&lt;/code&gt;钩子，默认会使用父路由的&lt;code&gt;model&lt;/code&gt;。&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_'&gt;其他值得注意的更新&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc__super-bug'&gt;当下的_super（破坏性Bug修复）&lt;/h4&gt;
&lt;p&gt;之前版本的Ember.js使用了对于织入不是那么安全的&lt;code&gt;super&lt;/code&gt;机制。如果一个指定函数名被多次调用&lt;code&gt;_super&lt;/code&gt;，并且没有终止函数，那么就会遇到死循环。&lt;a href="https://github.com/emberjs/ember.js/issues/3523"&gt;#3523&lt;/a&gt;有深入的讨论。&lt;/p&gt;

&lt;p&gt;1.5中得解决方案修复了这个问题（&lt;a href="https://github.com/emberjs/ember.js/pull/3683"&gt;#3683&lt;/a&gt;），这也破坏了使用&lt;code&gt;_super&lt;/code&gt;不一致。例如：&lt;/p&gt;
&lt;div class="highlight JavaScript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  &lt;span class="function"&gt;doIt&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    Ember.run.once(&lt;span class="local-variable"&gt;this&lt;/span&gt;, &lt;span class="local-variable"&gt;this&lt;/span&gt;._super);
  }
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;不在支持使用&lt;code&gt;_super&lt;/code&gt;，查看实例&lt;a href="http://emberjs.jsbin.com/xuroy/1/edit?html,js,output"&gt;jsbin&lt;/a&gt;。
如果个造成了影响，那么可以去&lt;a href="https://github.com/emberjs/ember.js/pull/4301"&gt;#4632&lt;/a&gt;参与讨论。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_handlebars-each'&gt;Handlebars {{each}} 助手检查标签&lt;/h4&gt;
&lt;p&gt;有些情况，浏览器会添加固定的标签，可能改变&lt;code&gt;Metamorph&lt;/code&gt;标签的递属关系。这个问题将成在开发人员忘记在一个表格中添加&lt;code&gt;TBODY&lt;/code&gt;的情况。这使得框架无法更新和清理底层DOM元素。&lt;/p&gt;

&lt;p&gt;非生产环境构建中添加了一个断言，用于指出&lt;code&gt;Metamorph&lt;/code&gt;的开始和结尾标签父元素不同的情况。这通常是在&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;中使用&lt;code&gt;{{each}}&lt;/code&gt;时没有指定&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;导致的。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://emberjs.jsbin.com/fotin/3/edit"&gt;JSBin&lt;/a&gt;展示了这个断言：&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;table&amp;gt;&lt;/span&gt;
  &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
    &lt;span class="tag"&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
  &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;解决办法就是添加&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;（&lt;a href="http://emberjs.jsbin.com/fotin/2/edit"&gt;JSBin&lt;/a&gt;）&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;table&amp;gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;tbody&amp;gt;&lt;/span&gt;
    &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
      &lt;span class="tag"&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
    &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;/tbody&amp;gt;&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_'&gt;其他改进&lt;/h3&gt;
&lt;p&gt;一如既往，本次发布还修改了许多之前版本存在的Bugs，对一部分功能也作出了一些改进。详细的内容可以查看CHANGELOG：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.5.0/CHANGELOG.md"&gt;Ember.js 1.5.0 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.6.0-beta.1/CHANGELOG.md"&gt;Ember.js 1.6.0-beta.1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data 1.0 之路</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2014/03/18/the-road-to-ember-data-1-0.html"/>
    <id>http://emberjs.cn/blog/2014/03/18/the-road-to-ember-data-1-0.html</id>
    <published>2014-03-18T00:00:00Z</published>
    <updated>2014-03-18T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; Ember Data即将迎来1.0时代。在能自信的保证不再破坏API之前，还需要实现最后几个特性。特别是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;保证在一个双向的关联中得一端发生改变时，另一端保持同步，即使其并未加载。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有关联将使用异步模式，&lt;code&gt;DataBoundPromises&lt;/code&gt;将确保其能再观察器、计算属性和模板中都能正常工作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;就像之前路由设计的尝试一样（已被证明是Javascript中得最好的实现），为了让Ember
Data更好的工作，花费了比设想要多很多的事件，不过现在其已经非常接近1.0正式版了。&lt;/p&gt;
...</summary>
    <content type="html">&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; Ember Data即将迎来1.0时代。在能自信的保证不再破坏API之前，还需要实现最后几个特性。特别是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;保证在一个双向的关联中得一端发生改变时，另一端保持同步，即使其并未加载。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有关联将使用异步模式，&lt;code&gt;DataBoundPromises&lt;/code&gt;将确保其能再观察器、计算属性和模板中都能正常工作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;就像之前路由设计的尝试一样（已被证明是Javascript中得最好的实现），为了让Ember
Data更好的工作，花费了比设想要多很多的事件，不过现在其已经非常接近1.0正式版了。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;在Ember 1.0发布后，基于Ember.js开发应用的开发者，非常感激在&lt;a href="http://semver.org"&gt;语义版本&lt;/a&gt;的保证下，获得升级的动力及升级后的稳定性。&lt;/p&gt;

&lt;p&gt;常常被问及“Ember.js非常棒，那么Ember Data怎么样呢？”现在，将告知Ember Data目前处于一个什么状态，还有就是不久的将来会变成什么样。&lt;/p&gt;

&lt;p&gt;首先，好消息是：在Ember Data 1.0发布之前只会做一个主要的破坏性改变，目前正在尽最大的努力希望做到本次修改尽可能少的影响到现有应用。&lt;/p&gt;

&lt;p&gt;在此之外，期望当前的特性集和API将会成为可见未来的稳定的基础。换而言之，不在希望为了容纳未来架构的改变，进行面向用户的破坏性修改。&lt;/p&gt;

&lt;p&gt;那么为什么还不发布1.0呢？主要是因为正在完成两个特性：一个是改进关联架构，另一个是使处理关联关系的API更加一致。&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_'&gt;唯一真理&lt;/h2&gt;
&lt;p&gt;记录间关联关系建模无疑是Ember Data中最难的特性。找到一个通用的方案非常的复杂，因此每个JSON服务器可能返回一种格式。当引入通过Websocket实现的流式改变就变得更加有意思了。&lt;/p&gt;

&lt;p&gt;最简单的办法就是宣告这个问题与领域相关度太高，每个开发人员应该自己选择一个简单的抽象方法手动的实现关联关系（例如使用计算属性）。&lt;/p&gt;

&lt;p&gt;然而却发现自己尝试为自己的领域模型关系构建最小化框架的开发者，不久都会放弃。就如在Ember中一样，都希望能梳理出一种抽象，能解决应用中得这些问题。&lt;/p&gt;

&lt;p&gt;因此希望能构建一种强大的可以为高级开发者节约开发时间，并且也能让Web客户端应用初学者能快速上手的方案。&lt;/p&gt;

&lt;p&gt;例如，有时一个&lt;code&gt;has-many&lt;/code&gt;关联关系可能保存在父记录的JSON中：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Lord Grantham&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: [&lt;span class="integer"&gt;2&lt;/span&gt;, &lt;span class="integer"&gt;3&lt;/span&gt;, &lt;span class="integer"&gt;4&lt;/span&gt;]
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;但是也可能被保存在子的一个外键：&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;2&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;name&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Lady Mary&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;parent_id&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同一个应用根据记录是否被加载或者保存，而同时提供两种格式的关联关系。&lt;/p&gt;

&lt;p&gt;当引入通过与服务器端的一个&lt;code&gt;socket&lt;/code&gt;链接来进行流式改变时，问题变得更加复杂，这里不进行详细的描述。&lt;/p&gt;

&lt;p&gt;强调这个复杂性德关键原因是表示不可以通过硬编码的方式来支持每种方式；每种表示都会与其他多种表示同时存在并相互协作。&lt;/p&gt;

&lt;p&gt;单向的关联关系问题并不大，在碰壁之前可以通过手动的方案很好的解决问题。真实的问题来源于双向的关联关系，例如：一篇文章有很多评论，而每一条评论又都属于这篇文章。&lt;/p&gt;

&lt;p&gt;由于关联关系的两端并不是总是同时加载的，而且每边都可能使用不同的方式表示关联关系（一个在评论中得主键，或者在文章中的一个数组），维护这个关系一直以来都非常的困难。&lt;/p&gt;

&lt;p&gt;特别在需要维护从服务端更新过来的数据的时候，这个问题变得尤为复杂。假设刷新文章时，提供了一个新的评论集合，而这时用户又正在创建新的评论。那么此时如何确保&lt;code&gt;comments&lt;/code&gt;数组能够考虑这些所有的因素？&lt;/p&gt;

&lt;p&gt;在上层，解决方法是这样的：作为在每条需要被同步的记录中保存关联关系的状态的一种替代方案，在内存中维护了一个实例，用来标识记录间的逻辑关联关系。无论应用加载了关联关系的那一端，这个实例便被创建。&lt;/p&gt;

&lt;p&gt;例如，如果在一条评论上修改了&lt;code&gt;belongs-to&lt;/code&gt;，那意味着改变了&lt;code&gt;has-many&lt;/code&gt;一端，即便文章并没有加载到应用中。当应用最终加载这篇文章时，应该可以将&lt;code&gt;belongs-to&lt;/code&gt;的改变应用到这篇文章。&lt;/p&gt;

&lt;p&gt;简单地说就是Ember Data 1.0维护关联关系的两端，使其一直保持同步，不论记录加载的顺序是如何的，也不理会加载的方式是什么，或者载荷中关联关系的表示是什么形式的。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/emberjs/data/tree/single-source-of-truth"&gt;single-source-of-truth&lt;/a&gt;分支正在完成这项工作，这里要特别感谢&lt;a href="https://github.com/igort"&gt;Igor Terzic&lt;/a&gt;，期望能很快的合并这个分支。&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_'&gt;异步关联关系&lt;/h2&gt;
&lt;p&gt;目前在Ember Data中，需要事先指定关联关系是异步的还是同步的。决定一个关联关系是否是异步的，需要知道服务器在发送数据给应用时是如何表达这些数据的。这并不太大的问题，但是却使得应用的语义与服务器端的语义紧密耦合。&lt;/p&gt;

&lt;p&gt;最严重的问题是开始重构服务端的API。例如，在一个&lt;code&gt;has-many&lt;/code&gt;关联关系中，可能会用一个客户端可以用来获取记录的URL来取代一个内联的记录ID的数组。&lt;/p&gt;

&lt;p&gt;一下子，应用就会以&lt;code&gt;Zalgo-esque&lt;/code&gt;的方式无法工作（如果没有阅读过Issaac的&lt;a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony"&gt;异步接口的优秀随笔&lt;/a&gt;，可以去看一看）。&lt;/p&gt;

&lt;p&gt;当设计API的时候，认真的考虑了重构的方便性，但在这个问题上犯错误了。对服务器端API的一些小得修改不应该影响到使用其的应用。&lt;/p&gt;

&lt;p&gt;它的价值在于不是所有的重构都是对等的。在这种情况下，发现所有的真实的应用程序，当其成长时，几乎总是围绕载荷来完成的，这样总是会遇到问题。（其他情况下，如果发现应用很好按照一个特定的方式改变，那么可能会采用惯例优于重构。）&lt;/p&gt;

&lt;p&gt;解决的方法是将所有的关联关系视作异步的，并使用承诺表示其值。通过依赖&lt;code&gt;Promises/A+&lt;/code&gt;来保证异步性，这样可以避免应用中出现&lt;code&gt;Zalgo&lt;/code&gt;。今后，如果关联关系的表示发生改变，或者关联关系加载的顺序发生改变，应用不需要做任何改变就可以如同之前一样工作。&lt;/p&gt;

&lt;p&gt;在JavaScript中使用承诺非常的简单：只需要调用&lt;code&gt;.then&lt;/code&gt;方法，并在回调中处理返回值即可。但是如果希望在模板或者一个计算属性中使用Ember Data的关联关系应该怎么办呢？它们又会以怎么样的形式工作呢？&lt;/p&gt;

&lt;p&gt;Ember Data 1.0引入了一个&lt;code&gt;Promise&lt;/code&gt;的子类&lt;code&gt;DataBoundPromise&lt;/code&gt;。这个对象允许如同观察一个不同对象的属性一样观察承诺的属性。当承诺被履行时，这些属性就会被更新来匹配基础对象。如果从一个&lt;code&gt;DataBoundPromise&lt;/code&gt;对象中&lt;code&gt;get&lt;/code&gt;一个属性，如果这个承诺并没有被履行，此时会返回&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; article = comment.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;article&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class="comment"&gt;// If the promise has not yet resolved&lt;/span&gt;
article.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;title&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;//=&amp;gt; undefined&lt;/span&gt;

&lt;span class="comment"&gt;// If the promise has resolved&lt;/span&gt;
article.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;title&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;//=&amp;gt; &amp;quot;Ember Data Roadmap&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;基于这个思想，在使用Ember Data绑定的上下文中（模板、计算属性和观察器），可以如同使用同步值一样使用关联关系，让数据绑定系统来处理承诺。这就意味着在大多数情形下，这个改变不会影响到现有的代码，并的确会提高在模板和计算属性中使用异步关联关系的技能（对于现今这是最主要的难点）。&lt;/p&gt;

&lt;p&gt;当在一个命令式的Javascript中（计算属性之外）使用关联对象时，则不应该依赖这种行为；在那种情况下，应该使用承诺的&lt;code&gt;then()&lt;/code&gt;方法来确保值的可用性，以免导致应用中出现&lt;code&gt;Zalgo&lt;/code&gt;。只有当承诺履行时，依赖Ember的数据绑定功能来更新模板或者计算属性，这时才应该使用&lt;code&gt;.get&lt;/code&gt;来获取&lt;code&gt;DataBoundPromise&lt;/code&gt;的属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 应该仅在观察器或者计算属性中使用&lt;code&gt;DataBoundPromise&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法。其余情况应该将其视为普通的承诺，并使用其&lt;code&gt;.then&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_'&gt;其他改进&lt;/h2&gt;
&lt;p&gt;在发布1.0之前，还将修复一系列的Bug。其中一些是目前还没有定义的行为，一些是希望确保应用不再依赖的Bug。&lt;/p&gt;

&lt;p&gt;最突出的是，目前&lt;code&gt;RESTAdapter&lt;/code&gt;在&lt;code&gt;pushPayload&lt;/code&gt;中处理嵌套的或者旁路载入的数据时错误的调用&lt;code&gt;normalize&lt;/code&gt;钩子。&lt;a href="https://github.com/emberjs/data/issues/1804"&gt;修复 #1804&lt;/a&gt;目前优先级很高，是阻碍发布1.0的一个关键问题之一。&lt;/p&gt;

&lt;p&gt;此外还需要保证1.0版本的文档应该具有一个高的质量标准，如同Ember一般。&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_'&gt;接下来&lt;/h2&gt;
&lt;p&gt;Ember Data将按照&lt;a href="http://semver.org"&gt;语义版本化&lt;/a&gt;来发布，因此需要为未来几年的发布提供一个稳定的基础。&lt;/p&gt;

&lt;p&gt;Ember.js未锁定API之前的迭代方案为以后几年的迭代提供了一个基础，其可以保证良好的向后兼容性。希望这一切也被用于到Ember Data中。&lt;/p&gt;

&lt;p&gt;一旦以上列出的问题一解决，就将发布Ember Data 1.0，此后一段时间将不在做破坏性的修改。另外将保持Ember.js和Ember Data的发布同步，因此Ember Data的第一个版本1.x版本将与那时的Ember的版本相同。&lt;/p&gt;

&lt;p&gt;例如，当Ember Data发布第一个稳定版本时，Ember.js的版本是1.7，那么Ember Data的第一个版本号也将是1.7。&lt;/p&gt;

&lt;p&gt;如同Ember.js，Ember
Data也将按照被Chrome影响的&lt;a href="http://emberjs.com/blog/2013/09/06/new-ember-release-process.html"&gt;六周发布方法&lt;/a&gt;。这种发布方法已经在可预见性和动力方面得到了证明，并且反馈都是积极正面的。重要的是，有这种分离的&lt;code&gt;stable&lt;/code&gt;，&lt;code&gt;beta&lt;/code&gt;和&lt;code&gt;canary&lt;/code&gt;发布也可以清晰的知道&lt;a href="http://emberjs.com/builds/#/beta"&gt;哪些特性是稳定的&lt;/a&gt;可以在生产环境中使用的，哪些还需要继续改进。&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_'&gt;数据框架&lt;/h2&gt;
&lt;p&gt;如&lt;a href="http://www.youtube.com/watch?v=jScLjUlLTLI"&gt;上周在Fluent上的基调&lt;/a&gt;中所述，框架存在是为了使得做正确的事情感觉比做错误的事情要好。通过在代码中编写最佳实践，框架使得社区可以构建未来的抽象，创建随时间变得越来越强大的良性循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember Data就是一个用来管理模型和关联关系的框架。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要使关联关系正确这一点非常难，但是通过向诱惑屈服，让每个人写自己的方案，那么社区就不能构建一个在关联关系概念之上的进一步的抽象。&lt;/p&gt;

&lt;p&gt;在早期，开始构建Ember Data时，尝试去编写好的实践，但是没有提供一种足够灵活的基本的底层作为逃逸值。因为人们总是与没有掌控能力的服务端进行交互，所以意识到有一个较好的逃逸值对Ember Data来说比惯例更加重要。&lt;/p&gt;

&lt;p&gt;为了确保确保社区依然能够基于Ember Data抽象进行构建，通过努力将应用之间不同的代码独立到适配器中。这就意味着，如果某人写了一个Ember Data插件，那么可以假设模型和关联关系在所有使用其的应用中都是一样的，尽管应用的后端可能不一样。&lt;/p&gt;

&lt;p&gt;在早期的Ember Data版本中，太过强调分离了，迫使每个应用在适配器层需要承受太大的代价。当六个月前重新启动Ember Data时，认真分析了如何在这些竞争问题间需求一种更好的平衡。基于此后获得的反馈，现在相信Ember Data已经非常适合每种有特殊后端的应用，就如同按照Ember Data的方式来构建一个后端的应用一般。&lt;/p&gt;

&lt;p&gt;现在需要保证1.0发布前所有的都能正确工作。Ember.js中得路由也经过了几个类似的迭代，就如同现在Ember Data遇到的苦恼一样，不过相信最终结果会为自己发声的。真实的使用对于设计过程非常的重要和有用，在发布之前仔细的思考问题也非常的重要。&lt;/p&gt;

&lt;p&gt;鉴于此，希望当宣布Ember Data符合1.0的质量要求时能得到大家的信任。如果现在开始使用Ember Data来构建应用，那么会因为将带来的有一个能分享理解的社区的向前的动力而高兴。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>EmberJS.CN一周岁</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2014/02/17/ember-js-cn-one-year-old.html"/>
    <id>http://emberjs.cn/blog/2014/02/17/ember-js-cn-one-year-old.html</id>
    <published>2014-02-17T00:00:00Z</published>
    <updated>2014-02-17T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;时间飞逝，日月如梭。从上线EmberJS.CN到今日，整整一周年过去了。一年里Ember社区改变了许多，特别是在Ember1.0正式版发布之后，更是发展迅速。不论是代码结构、新特性、运行的稳定性，还是文档、教程等等方面都有了很大的改进。时至今日，Ember.js已经发布了1.4.0版本，Ember Data也推出了1.0.0-beta.6版本，相信不久就会迎来ED的1.0正式版，届时肯定又会掀起整个社区的一次大骚动。&lt;/p&gt;

&lt;p&gt;在过去的一年里，Ember.js的里程碑：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2013-02-15 Ember...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;时间飞逝，日月如梭。从上线EmberJS.CN到今日，整整一周年过去了。一年里Ember社区改变了许多，特别是在Ember1.0正式版发布之后，更是发展迅速。不论是代码结构、新特性、运行的稳定性，还是文档、教程等等方面都有了很大的改进。时至今日，Ember.js已经发布了1.4.0版本，Ember Data也推出了1.0.0-beta.6版本，相信不久就会迎来ED的1.0正式版，届时肯定又会掀起整个社区的一次大骚动。&lt;/p&gt;

&lt;p&gt;在过去的一年里，Ember.js的里程碑：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2013-02-15 Ember.js发布1.0.0.rc.1&lt;/li&gt;
&lt;li&gt;2013-08-31 Ember.js发布1.0.0正式版&lt;/li&gt;
&lt;li&gt;2013-09-04 Ember Data发布1.0.0-beta.2&lt;/li&gt;
&lt;li&gt;2013-09-06 制定了Ember 1.0后发布策略&lt;/li&gt;
&lt;li&gt;2013-12-17 定义了2014年的开发计划 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;伴随着Ember.js的成长，EmberJS.CN也不断的在长大，不断的为我们中文社区的Ember开发作着贡献。下面简单的回顾一下这一年中EmberJS.CN都做了些什么。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2013-02-18 EmberJS.CN诞生&lt;/li&gt;
&lt;li&gt;2013-03-06 EmberJS.CN&lt;a href="http://weibo.com/embercn"&gt;开博&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2013-03-11 创建第一个QQ群（298026365）&lt;/li&gt;
&lt;li&gt;2013-04-06 &lt;a href="http://discuss.emberjs.cn"&gt;EmberJS.CN中文论坛&lt;/a&gt;上线&lt;/li&gt;
&lt;li&gt;2013-07-23 EmberJS.CN第一个开源项目&lt;a href="https://github.com/emberjs-cn/intimi"&gt;Intimi&lt;/a&gt;启动&lt;/li&gt;
&lt;li&gt;2013-09-10 Intimi 0.1.0发布&lt;/li&gt;
&lt;li&gt;2013-11-19 Intimi 0.2.0发布&lt;/li&gt;
&lt;li&gt;2013-12-15 完成与官方指南的同步&lt;a href="http://emberjs.cn/guides"&gt;翻译&lt;/a&gt;工作，并持续保持更新&lt;/li&gt;
&lt;li&gt;2014-02-15 EmberJS.CN第二个开源项目&lt;a href="https://github.com/emberjs-cn/ember-menglifang"&gt;Ember Menglifang&lt;/a&gt; 0.2.3发布&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在已经走在了2014年的日子里，EmberJS.CN将在未来的一年里持续的为大家服务，为Ember.JS在中文开发社区的推广努力。在这里也特别感谢一年以来大家对本网站的包容、谅解与支持。&lt;/p&gt;

&lt;p&gt;谢谢大家！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember 1.4.0和1.5 Beta发布</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2014/02/12/ember-1-4-0-and-ember-1-5-0-beta-released.html"/>
    <id>http://emberjs.cn/blog/2014/02/12/ember-1-4-0-and-ember-1-5-0-beta-released.html</id>
    <published>2014-02-12T00:00:00Z</published>
    <updated>2014-02-12T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;h3 class="anchorable-toc" id="toc_1-4"&gt;1.4中的新特性&lt;/h3&gt;&lt;h4 class="anchorable-toc" id="toc_"&gt;属性大括号扩展&lt;/h4&gt;
&lt;p&gt;在之前的Ember版本中，如果需要观察&lt;code&gt;baz&lt;/code&gt;的&lt;code&gt;foo&lt;/code&gt;和&lt;code&gt;bar&lt;/code&gt;属性，需要在同时设置&lt;code&gt;baz.foo&lt;/code&gt;和&lt;code&gt;baz.bar&lt;/code&gt;两个依赖键。&lt;/p&gt;
&lt;div class="highlight javascript "&gt;
&lt;div class="ribbon"&gt;&lt;/div&gt;
&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; obj = Ember.Object.extend({
  &lt;span class="key"&gt;baz&lt;/span&gt;: {&lt;span class="key"&gt;foo&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;BLAMMO&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;bar&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;BLAZORZ&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;},

  &lt;span class="function"&gt;something&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz.foo&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz...&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;</summary>
    <content type="html">&lt;h3 class='anchorable-toc' id='toc_1-4'&gt;1.4中的新特性&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;属性大括号扩展&lt;/h4&gt;
&lt;p&gt;在之前的Ember版本中，如果需要观察&lt;code&gt;baz&lt;/code&gt;的&lt;code&gt;foo&lt;/code&gt;和&lt;code&gt;bar&lt;/code&gt;属性，需要在同时设置&lt;code&gt;baz.foo&lt;/code&gt;和&lt;code&gt;baz.bar&lt;/code&gt;两个依赖键。&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; obj = Ember.Object.extend({
  &lt;span class="key"&gt;baz&lt;/span&gt;: {&lt;span class="key"&gt;foo&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;BLAMMO&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;bar&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;BLAZORZ&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;},

  &lt;span class="function"&gt;something&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz.foo&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz.bar&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz.foo&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz.bar&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用最新的属性大括号扩展，可以这样来简化依赖设置：&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  &lt;span class="function"&gt;something&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz.foo&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz.bar&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;baz.{foo,bar}&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样大大的简化了重复和冗余的相似依赖键的设置。&lt;/p&gt;

&lt;p&gt;详细的内容可以查看&lt;a href="https://github.com/emberjs/ember.js/pull/3538"&gt;PR #3538&lt;/a&gt;&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_ember-run-bind'&gt;Ember.run.bind&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Ember.run.bind&lt;/code&gt;是一个非常有用的工具，可以用来集成提供异步回调的非Ember库。&lt;/p&gt;

&lt;p&gt;Ember使用运行循环来批处理和合并更新。这是通过标记Ember相关代码的开始和结束执行来实现的。&lt;/p&gt;

&lt;p&gt;当使用事件时，如视图点击处理器，Ember把该处理器包裹在一个运行循环中。如果与非Ember库集成，那么就会变得非常让人厌烦。&lt;/p&gt;

&lt;p&gt;例如，下面的代码就非常的啰嗦，不过确实正确的处理第三方库事件的Ember代码：&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; that = &lt;span class="local-variable"&gt;this&lt;/span&gt;;
jQuery(window).on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;resize&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;(){
  Ember.run(&lt;span class="keyword"&gt;function&lt;/span&gt;(){
    that.handleResize();
  });
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了减少这种套式代码，下面的代码可以完成将回调包裹到一个运行循环中。&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;jQuery(window).on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;resize&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, Ember.run.bind(&lt;span class="local-variable"&gt;this&lt;/span&gt;, &lt;span class="local-variable"&gt;this&lt;/span&gt;.handleResize));
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;更多的关于运行循环的内容，请查看&lt;a href="/guides/understanding-ember/run-loop/"&gt;运行循环指南&lt;/a&gt;。（非常感谢&lt;a href="https://github.com/bfbriggs"&gt;Brendan Briggs&lt;/a&gt;）。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_code-with-code'&gt;支持控制器的&lt;code&gt;{{with}}&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;{{with}}&lt;/code&gt;助手现在可以接收一个&lt;code&gt;controller&lt;/code&gt;选项。添加&lt;code&gt;controller=&amp;#39;something&amp;#39;&lt;/code&gt;表示&lt;code&gt;{{with}}&lt;/code&gt;助手将创建和使用一个指定的控制器来作为其内容的新上下文。&lt;/p&gt;

&lt;p&gt;这与&lt;code&gt;{{each}}&lt;/code&gt;助手中使用&lt;code&gt;itemController&lt;/code&gt;选项非常类似。&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;with&lt;/span&gt; &lt;span class="attribute-name"&gt;users.posts&lt;/span&gt; &lt;span class="attribute-name"&gt;controller&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;userBlogPosts&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
  &lt;span class="comment"&gt;{{!- The current context is wrapped in our controller instance }}&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;with&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在上例中，提供给&lt;code&gt;{{with}}&lt;/code&gt;块的模板被包裹到&lt;code&gt;userBlogPost&lt;/code&gt;控制器中，这提供了一个非常简单的方法，来讲当前上下文中添加自定义的函数和属性。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;延迟绑定属性&lt;/h4&gt;
&lt;p&gt;之前，所有绑定的属性都有一定程度的开销（大部分是维护绑定和观察器之间的关联关系）。这导致需要限制自动绑定到&lt;code&gt;Ember.TextField&lt;/code&gt;，&lt;code&gt;Ember.TextArea&lt;/code&gt;等控件上的属性。对于越来越多的人希望绑定HTML5属性来说，这是一个问题的根源。为了多绑定属性，不得不重新打开&lt;code&gt;Ember.TextField&lt;/code&gt;类，然后添加可以绑定的属性。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Ember.TextField.reopen({
  &lt;span class="key"&gt;attributeBindings&lt;/span&gt;: [&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;autofocus&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;]
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后在模板中就可以：&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;input&lt;/span&gt; &lt;span class="attribute-name"&gt;autofocus&lt;/span&gt;=&lt;span class="attribute-value"&gt;omgAutofocusMe&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这当然不理想，对于那些认为&lt;code&gt;Ember.TextField&lt;/code&gt;理所当然支持的人来说，会遇到非常多问题。&lt;/p&gt;

&lt;p&gt;随着Ember 1.4的发布，这个问题得到了很好的处理。在1.4中，任何属性绑定在试图被渲染的时候如果不存在，那么不会为他设置观察器（因此避免了原本的性能开销问题）。当试图在之后又设置了该属性的时候（在初次渲染之后），一个属性观察器会在这时被添加。&lt;/p&gt;

&lt;p&gt;这意味着只会为存在的谁能够添加观察器，这样就可以在&lt;code&gt;attributeBindings&lt;/code&gt;中添加所有有效的HTML属性，今后就可以直接使用，而不需要在重新打开类来添加。&lt;/p&gt;

&lt;p&gt;在Ember 1.4中&lt;code&gt;{{input type=&amp;quot;text&amp;quot;}}&lt;/code&gt;，&lt;code&gt;{{textarea}}&lt;/code&gt;和&lt;code&gt;{{checkbox}}&lt;/code&gt;助手可以使用任何HTML5的属性。&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;其他改进&lt;/h4&gt;
&lt;p&gt;一如既往，本次发布还修改了许多之前版本存在的Bugs，对一部分功能也作出了一些改进。详细的内容可以查看CHANGELOG：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.4.0/CHANGELOG.md"&gt;Ember.js 1.4.0 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.5.0-beta.1/CHANGELOG.md"&gt;Ember.js 1.5.0-beta.1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>安全性发布 - Ember 1.2.2, and 1.3.2</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2014/02/07/ember-security-releases.html"/>
    <id>http://emberjs.cn/blog/2014/02/07/ember-security-releases.html</id>
    <published>2014-02-07T00:00:00Z</published>
    <updated>2014-02-07T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;因为开发者信任Ember.js在生产环境下来处理敏感的用户数据，因此Ember团队非常关注项目的安全问题。实际上，Ember是少数具有&lt;a href="http://emberjs.com/security/"&gt;清晰的安全策略&lt;/a&gt;和一个&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;为安全问题专设的邮件列表&lt;/a&gt;的Javascript项目之一。&lt;/p&gt;

&lt;p&gt;今天Ember.js发布了1.2.2，1.3.2和1.4.0-beta.6，其中包含了一个重要安全问题的修复：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.4.0-beta.6 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.4.0-beta.5...v1.4.0-beta.6"&gt;对比视图&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;1.3.2 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.3.1...v1.3.2"&gt;对比视图&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;1.2.2 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.2.1...v1.2.2"&gt;对比视图&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本次发布修复了一个XSS漏洞，在安全问题邮件列表中可以得到关于...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;因为开发者信任Ember.js在生产环境下来处理敏感的用户数据，因此Ember团队非常关注项目的安全问题。实际上，Ember是少数具有&lt;a href="http://emberjs.com/security/"&gt;清晰的安全策略&lt;/a&gt;和一个&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;为安全问题专设的邮件列表&lt;/a&gt;的Javascript项目之一。&lt;/p&gt;

&lt;p&gt;今天Ember.js发布了1.2.2，1.3.2和1.4.0-beta.6，其中包含了一个重要安全问题的修复：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.4.0-beta.6 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.4.0-beta.5...v1.4.0-beta.6"&gt;对比视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.3.2 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.3.1...v1.3.2"&gt;对比视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.2.2 -- &lt;a href="https://github.com/emberjs/ember.js/compare/v1.2.1...v1.2.2"&gt;对比视图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本次发布修复了一个XSS漏洞，在安全问题邮件列表中可以得到关于该漏洞的信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://groups.google.com/forum/#!topic/ember-security/1h6FRgr8lXQ"&gt;CVE-2014-0046&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;推荐马上更新项目。为了方便升级，本次发布的版本主要只包含了安全修复（1.4.0-beta.6除外，该版本是一个常规的beta发布，并包含了此次的安全修复）。&lt;/p&gt;

&lt;p&gt;如果在生产环境下使用Ember.js，请考虑订阅&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;安全通知邮件列表&lt;/a&gt;。该邮件列表流量非常低，且只包含安全通知。&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_'&gt;更多内容&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2013/04/05/announcing-the-ember-security-policy.html"&gt;Ember.js安全策略公告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/security/"&gt;Ember.js安全策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;Ember.js安全组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>使用Ember.SimpleAuth实现用户登录逻辑</title>
    <link rel="alternate" href="http://emberjs.cn/blog/2014/01/29/using-ember-simple-auth.html"/>
    <id>http://emberjs.cn/blog/2014/01/29/using-ember-simple-auth.html</id>
    <published>2014-01-29T00:00:00Z</published>
    <updated>2014-01-29T00:00:00Z</updated>
    <author>
      <name>EmberJS.CN</name>
    </author>
    <summary type="html">&lt;p&gt;Ember.SimpleAuth是一个实现身份认证和授权的轻量级的Ember.js库。通过配置身份认证和授权策略可以实现任意形式的身份认证和授权机制。&lt;/p&gt;
&lt;h3 class="anchorable-toc" id="toc_ember-simpleauth"&gt;搭建Ember.SimpleAuth开发环境&lt;/h3&gt;
&lt;p&gt;安装RubyGems。&lt;/p&gt;
&lt;div class="highlight bash "&gt;
&lt;div class="ribbon"&gt;&lt;/div&gt;
&lt;div class="scroller"&gt;
&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  cd /path/to/ember-simple-auth
  bundle install
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 class="anchorable-toc" id="toc_"&gt;运行测试&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在命令行中运行测试&lt;/p&gt;
&lt;div class="highlight bash "&gt;
&lt;div class="ribbon"&gt;&lt;/div&gt;
&lt;div class="scroller"&gt;
&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;rake test
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在浏览器中运行测试 &lt;/p&gt;
&lt;div class="highlight bash "&gt;
&lt;div class="ribbon"&gt;&lt;/div&gt;
&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;rackup

# 然后访问：http...&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    <content type="html">&lt;p&gt;Ember.SimpleAuth是一个实现身份认证和授权的轻量级的Ember.js库。通过配置身份认证和授权策略可以实现任意形式的身份认证和授权机制。&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-simpleauth'&gt;搭建Ember.SimpleAuth开发环境&lt;/h3&gt;
&lt;p&gt;安装RubyGems。&lt;/p&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  cd /path/to/ember-simple-auth
  bundle install
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_'&gt;运行测试&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在命令行中运行测试&lt;/p&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;rake test
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在浏览器中运行测试 &lt;/p&gt;
&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;rackup

# 然后访问：http://localhost:9292
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 class='anchorable-toc' id='toc_'&gt;运行示例&lt;/h4&gt;&lt;div class="highlight bash "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  cd examples
  bundle install

  ./runner

  # 然后访问：http://localhost:4567
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;</content>
  </entry>
</feed>
