
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="Description" content="Ember.js的中文开发者交流平台，提供Ember.js官方网站指南和API的中文翻译，持续关注最近的社区动态，为您提供高质量的Ember.js中文资料。 " />
    <meta name="Keywords" content="Ember.js、Ember、Javascript、Javascript框架、HTML、论坛、博客、中文社区" />
    <title>Ember.js - Ember 1.0 RC8发布</title>
    <meta property="st:title" content="Ember 1.0 RC8发布" />
    <link rel="shortcut icon" href="/images/favicon.png" />
    <!--[if lte IE 7 ]><link href="/stylesheets/fonts/fontello-ie7.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <link href="/stylesheets/site.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/emberjs-cn.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="http://emberjs.cn/blog/feed.xml" rel="alternate" type="application/atom+xml" title="Ember.js CN - 博客" />

    
  </head>

  <body class="blog blog_2013 blog_2013_08 blog_2013_08_28 blog_2013_08_28_ember-1-0-rc8">
    <div id="header">
      <div id="wrapper">
        <a id="logo" href="/">&nbsp;</a>
        <ul id="nav">
          <li><a href="/guides">指南</a></li>
          <li>
            <a target="_blank" href="http://discuss.emberjs.cn">论坛</a>
          </li>
          <li class="active"><a href="/blog">博客</a></li>
          <li>
            <a target="_blank" href="http://devdocs.io/ember/">API文档</a>
          </li>
          <li><a href="/builds">构建</a></li>
        </ul>
        <div id="github">
          <a href="https://github.com/emberjs-cn"><img src="/images/fork-us.png">Fork Us!</a>
          <a href="https://github.com/emberjs/ember.js"><img src="/images/fork-us.png">Fork Ember!</a>
        </div>
      </div>
    </div>

    <div id="content-wrapper">
      
      
        <div id="sidebar">
          <ol id='toc-list'>
  
    <li class='level-1'>
      <a href="/blog/tags/recent-posts.html">最近文章</a>
      <ol style="display:block">
        
          <li class='level-3'><a href="/blog/2014/02/17/ember-js-cn-one-year-old.html">EmberJS.CN一周岁</a></li>
        
          <li class='level-3'><a href="/blog/2014/02/12/ember-1-4-0-and-ember-1-5-0-beta-released.html">Ember 1.4.0和1.5 Beta发布</a></li>
        
          <li class='level-3'><a href="/blog/2014/02/07/ember-security-releases.html">安全性发布 - Ember 1.2.2, and 1.3.2</a></li>
        
          <li class='level-3'><a href="/blog/2014/01/29/using-ember-simple-auth.html">使用Ember.SimpleAuth实现用户登录逻辑</a></li>
        
          <li class='level-3'><a href="/blog/2014/01/28/how-to-use-ember-dev-to-develop-ember-packages.html">如何使用ember-dev来开发Ember包</a></li>
        
          <li class='level-3'><a href="/blog/2014/01/14/ember-security-releases.html">安全性发布 - Ember 1.0.1, 1.1.3, 1.2.1, and 1.3.1</a></li>
        
          <li class='level-3'><a href="/blog/2014/01/11/ember-data-1-0-0-beta-5.html">Ember Data 1.0.0.beta.5发布</a></li>
        
          <li class='level-3'><a href="/blog/2014/01/06/ember-1-3-0-and-ember-1-4-0-beta-released.html">Ember 1.3.0 and 1.4 Beta Released</a></li>
        
          <li class='level-3'><a href="/blog/2013/12/05/finish-translations.html">完成Ember指南中文翻译</a></li>
        
          <li class='level-3'><a href="/blog/2013/08/31/ember-1-0-released.html">Ember 1.0 Released</a></li>
        
          <li class='level-3'><a href="/blog/2013/08/28/ember-1-0-rc8.html">Ember 1.0 RC8发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/08/14/ember-1-0-rc7.html">Ember.js 1.0 RC7发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/08/14/setup-an-ember-app-on-windows-with-yeoman.html">Windows下Ember应用开发环境搭建</a></li>
        
          <li class='level-3'><a href="/blog/2013/07/06/ember-js-1-0-0-rc6.html">Ember.js 1.0.0-rc6发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/06/01/ember-js-1-0-0-rc5.html">Ember.js 1.0.0-rc5发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/04/25/two-different-ways-for-users-management-1.html">两种方式实现用户管理(一)</a></li>
        
          <li class='level-3'><a href="/blog/2013/04/25/two-different-ways-for-users-management-2.html">两种方式实现用户管理(二)</a></li>
        
          <li class='level-3'><a href="/blog/2013/04/23/ember-js-1-0-0-rc3.html">Ember.js 1.0.0-rc3发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/04/18/how-to-load-the-current-user.html">如何获取应用当前登录的用户信息</a></li>
        
          <li class='level-3'><a href="/blog/2013/03/31/ember-baby-steps.html">Ember入门实践</a></li>
        
          <li class='level-3'><a href="/blog/2013/03/29/ember-js-1-0-rc2-released.html">Ember.js 1.0.0-rc2发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/03/27/changed-the-directories-of-guides.html">指南目录结构调整</a></li>
        
          <li class='level-3'><a href="/blog/2013/03/11/ember-js-1-0-rc2.html">Ember.js准备发布RC2了</a></li>
        
          <li class='level-3'><a href="/blog/2013/03/06/domain-name-emberjs-cn-enabled.html">Emberjs.cn域名正式启用</a></li>
        
          <li class='level-3'><a href="/blog/2013/02/19/why-discourse-uses-ember.html">为什么Discourse选择Ember.JS</a></li>
        
          <li class='level-3'><a href="/blog/2013/02/18/come-into-being.html">EmberJS.CN之诞生</a></li>
        
      </ol>
    </li>
  
  
    <li class='level-1'>
      <a href="/blog/tags/releases.html">发布说明</a>
      <ol style="display:block">
        
          <li class='level-3'><a href="/blog/2014/02/12/ember-1-4-0-and-ember-1-5-0-beta-released.html">Ember 1.4.0和1.5 Beta发布</a></li>
        
          <li class='level-3'><a href="/blog/2014/02/07/ember-security-releases.html">安全性发布 - Ember 1.2.2, and 1.3.2</a></li>
        
          <li class='level-3'><a href="/blog/2014/01/14/ember-security-releases.html">安全性发布 - Ember 1.0.1, 1.1.3, 1.2.1, and 1.3.1</a></li>
        
          <li class='level-3'><a href="/blog/2014/01/11/ember-data-1-0-0-beta-5.html">Ember Data 1.0.0.beta.5发布</a></li>
        
          <li class='level-3'><a href="/blog/2014/01/06/ember-1-3-0-and-ember-1-4-0-beta-released.html">Ember 1.3.0 and 1.4 Beta Released</a></li>
        
          <li class='level-3'><a href="/blog/2013/08/31/ember-1-0-released.html">Ember 1.0 Released</a></li>
        
          <li class='level-3'><a href="/blog/2013/08/28/ember-1-0-rc8.html">Ember 1.0 RC8发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/08/14/ember-1-0-rc7.html">Ember.js 1.0 RC7发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/07/06/ember-js-1-0-0-rc6.html">Ember.js 1.0.0-rc6发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/06/01/ember-js-1-0-0-rc5.html">Ember.js 1.0.0-rc5发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/04/23/ember-js-1-0-0-rc3.html">Ember.js 1.0.0-rc3发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/03/29/ember-js-1-0-rc2-released.html">Ember.js 1.0.0-rc2发布</a></li>
        
          <li class='level-3'><a href="/blog/2013/03/27/changed-the-directories-of-guides.html">指南目录结构调整</a></li>
        
          <li class='level-3'><a href="/blog/2013/03/11/ember-js-1-0-rc2.html">Ember.js准备发布RC2了</a></li>
        
      </ol>
    </li>
  
  
    <li class='level-1'>
      <a href="/blog/tags/weekly.html">Ember.js周报</a>
      <ol style="display:block">
        
          <li class='level-3'><a href="/blog/2013/06/14/ember-js-weekly.html">第七期周报</a></li>
        
          <li class='level-3'><a href="/blog/2013/05/30/ember-js-weekly.html">第六期周报</a></li>
        
          <li class='level-3'><a href="/blog/2013/05/24/ember-js-weekly.html">第五期周报</a></li>
        
          <li class='level-3'><a href="/blog/2013/05/17/ember-js-weekly.html">第四期周报</a></li>
        
          <li class='level-3'><a href="/blog/2013/05/09/ember-js-weekly.html">第三期周报</a></li>
        
          <li class='level-3'><a href="/blog/2013/05/02/ember-js-weekly.html">第二期周报</a></li>
        
          <li class='level-3'><a href="/blog/2013/04/25/ember-js-weekly.html">第一期周报</a></li>
        
      </ol>
    </li>
  
</ol>

          <div id="back-to-top"><a id="back-top-top" href="#">&#11014; 返回顶部</a></div>
        </div>
      
      <div id="content" class="has-sidebar">
          <article class="blog-post">
    <h1>Ember 1.0 RC8发布</h1>
    

    <hr>

    <p>Ember 1.0 RC8是1.0正式版前的最后一次发布，如果一切顺利本周末将发布Ember
1.0正式版。</p>

<p>在RC8中做了一些1.0正式版之前的重大更改，这些更改对应用代码只有很少的影响，不过带来了很大的性能提升。</p>

<p>这些更改都与观察器有关。如果编码的时候使用了大量的观察器，那么可能意味着代码不符合语言习惯。通常只在与其他不支持绑定机制的库桥接的时候需要使用观察器。</p>

<p>例如，如果编写一个包裹jQuery
UI控件的组件时，可能需要使用观察器来监视组件上的改变，并将这些改变反映到控件上。</p>

<p>在应用代码中，应该尽可能的使用计算属性。</p>
<h4 class='anchorable-toc' id='toc_'>声明事件监听器</h4>
<p>现在Ember提供了一种方法来用声明的方式给Ember类添加事件监听器。这比手动在<code>init</code>中设置监听器要简单很多。</p>

<p>以前的方法：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre>App.Person = DS.Model.extend({
  <span class="function">init</span>: <span class="keyword">function</span>() {
    <span class="local-variable">this</span>.on(<span class="string"><span class="delimiter">'</span><span class="content">didLoad</span><span class="delimiter">'</span></span>, <span class="local-variable">this</span>, <span class="keyword">function</span>() {
      <span class="local-variable">this</span>.finishedLoading();
    });
  },

  <span class="function">finishedLoading</span>: <span class="keyword">function</span>() {
    <span class="comment">// do stuff</span>
  }
});
</pre></td>
</tr></table>
</div></div>
<p>现在只需要：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.Person = DS.Model.extend({
  <span class="function">finishedLoading</span>: <span class="keyword">function</span>() {
    <span class="comment">// do stuff</span>
  }.on(<span class="string"><span class="delimiter">'</span><span class="content">didLoad</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div><h4 class='anchorable-toc' id='toc_'>数组计算</h4>
<p>现在有一种符合惯例和稳定的方法来构建一个基于数组的计算属性，其将只对更新的部分进行计算。</p>

<p>例如，当有一组people时，并想通过一个计算属性返回他们的年龄。</p>

<p>当前最简单的实现方法是：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.Person = Ember.Object.extend({
  <span class="function">childAges</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">children</span><span class="delimiter">'</span></span>).mapBy(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>);
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">children.@each.age</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div>
<p>这样实现非常简洁，但是当数组中任何时候有一个元素被添加或者删除时，就会重新计算整个数组。对于小的数组来说，这可能不成问题。然而，如果数组非常巨大，或者这些计算属性被链式使用，或者用于完成一些繁重的工作，那么开销将会非常大。</p>

<p>这时可以使用数组计算属性性：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>App.Person = Ember.Object.extend({
  <span class="key">childAges</span>: Ember.computed.mapBy(<span class="string"><span class="delimiter">'</span><span class="content">children</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div>
<p>可以将数组计算属性链接在一起：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.Person = Ember.Object.extend({
  <span class="key">childAges</span>: Ember.computed.mapBy(<span class="string"><span class="delimiter">'</span><span class="content">children</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>),
  <span class="key">maxChildAge</span>: Ember.computed.max(<span class="string"><span class="delimiter">'</span><span class="content">childAges</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div>
<p>当一个元素被添加或者删除时，计算只进行一次。在本例中，如果添加一个孩子，那他的年龄会被追加到<code>childAges</code>中，并且如果这个年龄大于<code>maxChildAge</code>，那么<code>maxChildAge</code>也将得到更新。</p>

<p>这些计算属性总是保持同步、高效，并完全由Ember来管理。</p>
<h4 class='anchorable-toc' id='toc_ember'>Ember扩展</h4>
<p>经过几个月的测试，及Teddy Zeenny的辛勤付出，Ember
Inspector已经准备发布到Chrome Web Store了。</p>

<p>最近，Teddy添加了对加载的数据的支持。已经支持Ember Data，Ember
Model的支持也在开发中。</p>

<p><img src="/images/blog/rc8-ember-data.png"></p>

<p>Teddy完成了对象检查器的重大改进，增加了对组属性对象的支持（如：Ember
Data模型的属性、一对多关联），支持通过检查器修改对象。</p>

<p><img src="/images/blog/rc8-editing.png"></p>

<p>通过检查器可以查看应用中所有路由的列表，这些命名可以与对象结合使用。这样更容易记住命名惯例。</p>

<p><img src="/images/blog/rc8-routes.png"></p>

<p>另外，视图树通过应用模板关联的控制器和模型显示了应用的概况。</p>

<p><img src="/images/blog/rc8-view-tree.png"></p>
<h4 class='anchorable-toc' id='toc_'>其他改进</h4>
<ul>
<li>改进<code>yield</code>，确保其总是<code>yield</code>回调用的上下文。</li>
<li>不使用W3C range API来改进range更新的性能</li>
<li>完成1.0文档的审查</li>
<li>通过<code>&lt;script&gt;</code>重复定义同名的模板时给出更加友好的错误消息</li>
<li>在<code>ApplicationController</code>中添加<code>currentRouteName</code>，可以用于<code>link-to</code>和<code>transitionTo</code>。</li>
<li>定义新的别名：<code>linkTo</code> -&gt; <code>link-to</code>，<code>bindAttr</code> -&gt; <code>bind-attr</code>，来保持与html命名一致。老命名还保留不过已经软废除。</li>
</ul>
<h4 class='anchorable-toc' id='toc_tl-dr'>更新 TL;DR</h4><h5 class='anchorable-toc' id='toc_'>观察器在构造过程中不触发</h5>
<p>以前通过<code>create</code>传入或者在prototype上指定的属性不会触发观察器，但在<code>init</code>中通过<code>set</code>方法设置的属性会触发。</p>

<p>现在观察器直到<code>init</code>完后才会触发观察器。</p>

<p>如果在初始化过程中需要出发一个观察器，不能通过<code>set</code>来实现，需要在观察器上通过<code>.on(&#39;init&#39;)</code>指定其在<code>init</code>下也工作。</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre>App.Person = Ember.Object.extend({
  <span class="function">init</span>: <span class="keyword">function</span>() {
    <span class="local-variable">this</span>.set(<span class="string"><span class="delimiter">'</span><span class="content">salutation</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mr/Ms</span><span class="delimiter">&quot;</span></span>);
  },

  <span class="function">salutationDidChange</span>: <span class="keyword">function</span>() {
    <span class="comment">// some side effect of salutation changing</span>
  }.observes(<span class="string"><span class="delimiter">'</span><span class="content">salutation</span><span class="delimiter">'</span></span>).on(<span class="string"><span class="delimiter">'</span><span class="content">init</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div><h5 class='anchorable-toc' id='toc_'>没有消费的计算属性不触发观察器</h5>
<p>如果从未<code>get</code>一个计算属性，与它相关的观察器不会被触发，即使其依赖的键已经改变。可以想象为值从一个未知的值变成了另一个。</p>

<p>这基本上不会影响到应用程序代码，因为计算属性几乎总是在其取来的时候同时被观察到。例如，获取一个计算属性的值，将其放置到DOM中，（或者通过D3绘图），接着观察它，以便在其更新的时候更新DOM。</p>

<p>如果需要观察一个不需要立即使用的计算属性，可以在<code>init</code>方法中<code>get</code>它一下。</p>
<h5 class='anchorable-toc' id='toc_'>路由、控制器和视图的新操作哈希</h5>
<p>为了保持一致性并提供更灵活的操作命名，通过一个统一的<code>actions</code>哈希来定义操作。当继承一个定义了<code>actions</code>的类时，会在子类将定义的<code>actions</code>进行合并，或在父进行实例化。另外还支持<code>_super</code>，因此没有散失任何的灵活性。</p>

<p>之前的行为依然支持，不过已经废除了。如果一个控制器代理了一个拥有<code>actions</code>属性的模型，那么将自动将其重命名为<code>_actions</code>来避免发生任何可能的冲突。</p>
<h5 class='anchorable-toc' id='toc_handlebars'>在Handlebars助手中使用引号引起来的字符串</h5>
<p>过去，Handlebars助手没有严格限制字符串是否需要加引号。不幸的是，这意味着没有办法区分字符串值和属性路径。现在严格限制如果希望是一个字符串值的话，必须加引号。这意味着<code>link-to</code>的路由名必须用引号引起来。相反，如果定义一个自定义的绑定助手，并且用一个引号引起来的字符表示属性路径，这将不再工作。加引号表示字符串，不加表示路径。</p>
<h4 class='anchorable-toc' id='toc_code-init-code'>在<code>init</code>中设置属性</h4>
<p>当前，传递一个哈希给<code>create</code>和在<code>init</code>中设置同样的属性是不一致的。</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>App.Person = Ember.Object.extend({
  <span class="function">firstNameDidChange</span>: <span class="keyword">function</span>() {
    <span class="comment">// this observer does not fire</span>
  }.observes(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>)
});

App.Person.create({ <span class="key">firstName</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Tom</span><span class="delimiter">&quot;</span></span>, <span class="key">lastName</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Dale</span><span class="delimiter">&quot;</span></span> });
</pre></td>
</tr></table>
</div></div>
<p>本例中，由于所有属性都是通过一个传给<code>create</code>的hash来设置的，观察器不会被触发。</p>

<p>下面看一看在RC7中在<code>init</code>方法里完成同样的出发会发生什么：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="comment">// WARNING: OLD BEHAVIOR</span>

App.Person = Ember.Object.extend({
  <span class="function">init</span>: <span class="keyword">function</span>() {
    <span class="keyword">if</span> (!<span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>)) {
      <span class="local-variable">this</span>.set(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Tom</span><span class="delimiter">&quot;</span></span>);
    }
  },
  <span class="function">firstNameDidChange</span>: <span class="keyword">function</span>() {
    <span class="comment">// this observer fires</span>
  }.observes(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>)
});

App.Person.create({ <span class="key">lastName</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Dale</span><span class="delimiter">&quot;</span></span> });
</pre></td>
</tr></table>
</div></div>
<p>在此，如果<code>firstName</code>没有，也会出发观察器。</p>

<p>新的设计对象模型只在构造后会触发观察器，这是为什么<code>create</code>不触发的原因。</p>

<p>此外，因为如果为包含数组、对象值的属性进行初始化只能在<code>init</code>中，这导致了不一致性：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre><span class="comment">// WARNING: OLD BEHAVIOR</span>

App.Person = Ember.Object.extend({
  <span class="comment">// initial property value, does not trigger an initialization observer</span>
  <span class="key">salutation</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mr.</span><span class="delimiter">&quot;</span></span>,

  <span class="function">init</span>: <span class="keyword">function</span>() {
    <span class="comment">// also initial property value, triggers an observer on</span>
    <span class="comment">// initialization</span>
    <span class="local-variable">this</span>.set(<span class="string"><span class="delimiter">'</span><span class="content">children</span><span class="delimiter">'</span></span>, []);
  }
});
</pre></td>
</tr></table>
</div></div>
<p>总之，属性在初始化过程中被设置不论是否设置到prototype，或作为哈希传给<code>create</code>，或在<code>init</code>中被设置，都不触发观察器。</p>

<p>如果有代码需要不论是在初始化过程还是当一个属性改变时执行，必须使用<code>.on(&#39;init&#39;)</code>将其标记为需要在初始化过程执行。这种情况最好是进行重构，来避免<code>init</code>时<code>set</code>的负面效应。</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.Person = Ember.Object.extend({
  <span class="function">firstNameDidChange</span>: <span class="keyword">function</span>() {
    <span class="comment">// some side effect that happens when first name changes</span>
  }.observes(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>).on(<span class="string"><span class="delimiter">'</span><span class="content">init</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div><h4 class='anchorable-toc' id='toc_'>计算属性性能改进</h4>
<p>最新发布的Ember.js版本包含了观察器和计算属性交互的更新。这对依赖旧有行为的应用是一个破坏性的更新。</p>

<p>为了理解这个更新，通过一个计算属性的例子来介绍。假设尝试用Ember.js对象来为<a href="http://en.wikipedia.org/wiki/Schr%C3%B6dinger&#x27;s_cat">Schrödinger&#39;s famous cat</a> 建模。</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>App.Cat = Ember.Object.extend({
  <span class="function">isDead</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> Math.rand() &gt; <span class="float">0.5</span>;
  }.property()
});

<span class="keyword">var</span> cat = App.Cat.create();
</pre></td>
</tr></table>
</div></div>
<p>给定一个猫的对象，判断猫是死是活？这里通过一个随机数来决定。在观察猫对象之前，可以说猫既是死的又是活的，或者要死不活。</p>

<p>而实际上，并非猫超凡脱俗，而是取决于第一次调用。</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
</pre></td>
  <td class="code"><pre>cat.get(<span class="string"><span class="delimiter">'</span><span class="content">isDead</span><span class="delimiter">'</span></span>);
<span class="comment">// true</span>
<span class="comment">// …or false, half the time</span>
</pre></td>
</tr></table>
</div></div>
<p>在询问了猫对象的<code>isDead</code>属性后，就可以明确的说猫是死还是活。但是在此之前，这个计算属性的值并不存在。</p>

<p>下面看看在混合（Mix）中的观察器。如果计算属性的值还不存在，其依赖的键发生改变时是否触发观察器？</p>

<p>在之前版本的Ember.js中，答案是肯定的。例如：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
</pre></td>
  <td class="code"><pre>App.Person = Ember.Object.extend({
  <span class="key">observerCount</span>: <span class="integer">0</span>,

  <span class="function">fullName</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>);
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>),

  <span class="function">fullNameDidChange</span>: <span class="keyword">function</span>() {
    <span class="local-variable">this</span>.incrementProperty(<span class="string"><span class="delimiter">'</span><span class="content">observerCount</span><span class="delimiter">'</span></span>);
  }.observes(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div>
<p>依赖的任意键发生改变，都会触发观察者：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="comment">// WARNING: OLD BEHAVIOR DO NOT RELY ON THIS</span>

<span class="keyword">var</span> person = App.Person.create({
  <span class="key">firstName</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Yehuda</span><span class="delimiter">&quot;</span></span>,
  <span class="key">lastName</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Katz</span><span class="delimiter">&quot;</span></span>
});

person.get(<span class="string"><span class="delimiter">'</span><span class="content">observerCount</span><span class="delimiter">'</span></span>); <span class="comment">// =&gt; 0</span>

person.set(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Tomhuda</span><span class="delimiter">&quot;</span></span>);
person.get(<span class="string"><span class="delimiter">'</span><span class="content">observerCount</span><span class="delimiter">'</span></span>); <span class="comment">// =&gt; 1</span>

person.set(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Katzdale</span><span class="delimiter">&quot;</span></span>);
person.get(<span class="string"><span class="delimiter">'</span><span class="content">observerCount</span><span class="delimiter">'</span></span>); <span class="comment">// =&gt; 2</span>
</pre></td>
</tr></table>
</div></div>
<p>然后，因为<code>fullName</code>属性并不&quot;exist&quot;直到请求它为止，触发一个观察者是否是正确的行为并不明确。</p>

<p>一个影响计算属性的关联问题是如果计算属性依赖键包含一个路径。（请记住依赖键只是定义一个计算属性时，传递个<code>.property()</code>方法的属性名。</p>

<p>例如，假设构造一个模型表示一篇博客，如果需要使用博客的评论，采用延迟加载的方式加载评论（例如在模板中）。</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre>App.BlogPost = Ember.Object.extend({
  <span class="function">comments</span>: <span class="keyword">function</span>() {
    <span class="keyword">var</span> comments = [];
    <span class="keyword">var</span> url = <span class="string"><span class="delimiter">'</span><span class="content">/post/</span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">id</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">/comments.json</span><span class="delimiter">'</span></span>);

    <span class="predefined">$</span>.getJSON(url).then(<span class="keyword">function</span>(data) {
      data.forEach(<span class="keyword">function</span>(comment) {
        comments.pushObject(comment);
      });
    });

    <span class="keyword">return</span> comments;
  }.property()
});
</pre></td>
</tr></table>
</div></div>
<p>在这里跟预期的行为一样，博文的评论只会在第一次使用<code>post.get(&#39;comments&#39;)</code>或者在模板中使用的时候，才通过网络去加载：</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="tag">&lt;ul&gt;</span>
<span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">each</span> <span class="attribute-name">comments</span><span class="inline-delimiter">}}</span></span>
  <span class="tag">&lt;li&gt;</span><span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">title</span><span class="inline-delimiter">}}</span></span><span class="tag">&lt;/li&gt;</span>
<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">each</span><span class="inline-delimiter">}}</span></span>
<span class="tag">&lt;/ul&gt;</span>
</pre></td>
</tr></table>
</div></div>
<p>然而，现在希望添加一个计算属性，用来从加载的评论中选择第一条：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre>App.BlogPost = Ember.Object.extend({
  <span class="function">comments</span>: <span class="keyword">function</span>() {
    <span class="keyword">var</span> comments = [];
    <span class="keyword">var</span> url = <span class="string"><span class="delimiter">'</span><span class="content">/post/</span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">id</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">/comments.json</span><span class="delimiter">'</span></span>;

    <span class="predefined">$</span>.getJSON(url).then(<span class="keyword">function</span>(data) {
      data.forEach(<span class="keyword">function</span>(comment) {
        comments.pushObject(comment);
      });
    });

    <span class="keyword">return</span> comments;
  }.property(),

  <span class="function">firstComment</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">comments.firstObject</span><span class="delimiter">'</span></span>);
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">comments.firstObject</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div>
<p>现在有了一个问题！因为<code>firstComment</code>计算属性依赖<code>comments.firstObject</code>，为了建立一个<code>firstObject</code>的观察器，它将<code>get()</code><code>comments</code>属性。</p>

<p>在此添加这个计算属性意味着应用中所有博文的评论都被加载，无论评论是否被使用！</p>

<p>为了决定如何处理，花了一些时间分析实际的Ember.js应用。发现这个行为严重的影响了性能。</p>

<ol>
<li>触发没有物化的计算属性的观察器意味着需要在一开始的时候为所有计算属性设置监听器，而不是在第一次计算的时候。</li>
<li>许多计算属性因为路径依赖键，从未使用，也未被计算。</li>
</ol>

<p>为了修正这些问题，<strong>RC8做了一下改变</strong>：</p>

<ol>
<li>观察一个计算属性的观察器只在该属性被使用过至少一次后才会被触发。</li>
<li>观察一个路径（<code>&quot;foo.bar.baz&quot;</code>），或者使用一个路径作为一个依赖主键，将不导致路径任意部分从未计算变为计算。</li>
</ol>

<p>大部分Ember.js应用程序不会受此影响，因为：</p>

<ol>
<li>大部分应用程序观察计算属性，并且在对象初始化时就<code>get()</code>这些属性，因而触发了正确的行为。</li>
<li>对于计算属性依赖键，新行为正是开发者所期待的。</li>
</ol>

<p>如果应用受这个更改的影响，修正方法非常简单，只需要在类的<code>init</code>方法中<code>get()</code>计算属性即可。</p>

<p>例如，为了更新上述的观察器例子，能通过&quot;precomputing&quot;<code>fullName</code>属性来保持RC8之前版本的行为：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
</pre></td>
  <td class="code"><pre>App.Person = Ember.Object.extend({
  <span class="function">init</span>: <span class="keyword">function</span>() {
    <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>);
    <span class="local-variable">this</span>._super();
  },

  <span class="key">observerCount</span>: <span class="integer">0</span>,

  <span class="function">fullName</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>);
  }.property(<span class="string"><span class="delimiter">'</span><span class="content">firstName</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">lastName</span><span class="delimiter">'</span></span>),

  <span class="function">fullNameDidChange</span>: <span class="keyword">function</span>() {
    <span class="local-variable">this</span>.incrementProperty(<span class="string"><span class="delimiter">'</span><span class="content">observerCount</span><span class="delimiter">'</span></span>);
  }.observes(<span class="string"><span class="delimiter">'</span><span class="content">fullName</span><span class="delimiter">'</span></span>)
});
</pre></td>
</tr></table>
</div></div><h4 class='anchorable-toc' id='toc_code-link-to-code'><code>link-to</code>绑定参数</h4>
<p><code>link-to</code>助手（之前为<code>linkTo</code>）现在将未加引号的参数（非数字参数）作为绑定属性路径对待，这意味着当一个传给<code>link-to</code>的属性改变时，链接的<code>href</code>将改变。这包括第一个参数（目标路由名）和接着的任意上下文参数。</p>

<p>下面的模板例子将在当前上下文（通常是一个控制器）查找<code>destinationRoute</code>，并使用其来决定链接的<code>href</code>和点击链接将切换至的路由。</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">link-to</span> <span class="attribute-name">destinationRoute</span><span class="inline-delimiter">}}</span></span>Link Text<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">link-to</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>下面的例子将一直指向<code>articles.show</code>路由（因为路由名称参数加了引号），但是当<code>article</code>的值改变时，链接的<code>href</code>将更新为对应<code>article</code>新值的URL。</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
</pre></td>
  <td class="code"><pre><span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">link-to</span> <span class="error">'</span><span class="attribute-name">articles.show</span><span class="error">'</span> <span class="attribute-name">article</span><span class="inline-delimiter">}}</span></span>Read More...<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">link-to</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>如果之前写的应用没有正确的区分加引号的字符串和属性路径，这可能导致一些问题。因此当升级到RC8时，需要确定所有<code>link-to</code>参数的静态字符串都正确的添加了引号。</p>
<h4 class='anchorable-toc' id='toc_'>绑定助手：加引号的字符串，数字和路径</h4>
<p>调用自定义的绑定助手（如通过<code>Ember.Handlebars.helper</code>定义的）时传入加引号的字符串或者原生数字会将其原值直接传入，而不是将所有的都作为绑定属性的路径，每次在属性变化的时候都重新渲染助手。</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>Pass the string 'hello' to myHelper:
<span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">myHelper</span> <span class="error">'</span><span class="attribute-name">hello</span><span class="error">'</span><span class="inline-delimiter">}}</span></span>

Pass the property pointed-to by the path 'hello' to myHelper:
<span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">myHelper</span> <span class="attribute-name">hello</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>如果之前调用绑定助手时传入加引号的字符串，并期望其是一个绑定属性路径，那么会导致应用出现一些问题。因此需要确定只有当确实需要传入一个字符串的时候才给参数加引号，而不是路径对应的值。
如果之前写的应用没有正确的区分加引号的字符串和属性路径，这可能导致一些问题。因此当升级到RC8时，需要确定所有<code>link-to</code>参数的静态字符串都正确的添加了引号。</p>


    <hr>

    <div id="disqus_thread"></div> 
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'emberjs-cn'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript><a href="http://disqus.com/?ref_noscript">基于Disqus的评论需要启用Javascript</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">博客评论基于<span class="logo-disqus">Disqus</span></a>
  </article>

      </div>
    </div>

    <div id="footer">
      <div id="footer-wrapper">
        <div class="info">&copy; 2014 Emberjs.CN <br/>Design by <a href="http://www.heropixel.com">HeroPixel</a></div>
        <div class="statement"><b>声明：</b>本站的文章可以随意在网上转载，但必须注明原文出处！</div>
        <div class="links">
          <a href="http://weibo.com/embercn"><img src="/images/weibo.png"/></a>
          <a href="http://emberjs.cn/blog/feed.xml"><img src="/images/feed.png"/></a>
        </div>
      </div>
    </div>

<!--[if lt IE 9]>
    <script type="text/javascript" src="/javascripts/common-old-ie.js"></script>
<![endif]-->
<!--[if gte IE 9]><!-->
    <script type="text/javascript" src="/javascripts/common-modern.js"></script>
<!--<![endif]-->

    

    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl = '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-38578402-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">
      var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
      document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F0b0fcec01b06cc76e274f7b21f4766c4' type='text/javascript'%3E%3C/script%3E"));

      $(function() {
        $('a[href="http://tongji.baidu.com/hm-web/welcome/ico?s=0b0fcec01b06cc76e274f7b21f4766c4"]').hide();
      });
    </script>

  </body>
</html>
