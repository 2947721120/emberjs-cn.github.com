

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="Description" content="Ember.js的中文开发者交流平台，提供Ember.js官方网站指南和API的中文翻译，持续关注最近的社区动态，为您提供高质量的Ember.js中文资料。 " />
    <meta name="Keywords" content="Ember.js、Ember、Javascript、Javascript框架、HTML、论坛、博客、中文社区" />
    <title>Ember.js - 加载中/错误子状态</title>
    <meta property="st:title" content="加载中/错误子状态" />
    <link rel="shortcut icon" href="/images/favicon.png" />
    <!--[if lte IE 7 ]><link href="/stylesheets/fonts/fontello-ie7.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <link href="/stylesheets/site.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/emberjs-cn.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="http://emberjs.cn/blog/feed.xml" rel="alternate" type="application/atom+xml" title="Ember.js CN - 博客" />

    
  </head>

  <body class="bilingual_guides bilingual_guides_routing bilingual_guides_routing_loading-and-error-substates bilingual_guides_routing_loading-and-error-substates_index">
    <div id="header">
      <div id="wrapper">
        <a id="logo" href="/">&nbsp;</a>
        <ul id="nav">
          <li><a href="/guides">指南</a></li>
          <li>
            <a target="_blank" href="http://discuss.emberjs.cn">论坛</a>
          </li>
          <li><a href="/blog">博客</a></li>
          <li>
            <a target="_blank" href="http://devdocs.io/ember/">API文档</a>
          </li>
          <li><a href="/builds">构建</a></li>
        </ul>
        <div id="github">
          <a href="https://github.com/emberjs-cn"><img src="/images/fork-us.png">Fork Us!</a>
          <a href="https://github.com/emberjs/ember.js"><img src="/images/fork-us.png">Fork Ember!</a>
        </div>
      </div>
    </div>

    <div id="content-wrapper">
      
      
        <div id="sidebar">
          
    <ol id="toc-list">
          <li class="level-1">
            <a href="/bilingual_guides/getting-started">入门指南</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/getting-started">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/planning-the-application">应用规划</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/creating-a-static-mockup">创建静态页面</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/obtaining-emberjs-and-dependencies">获取Ember.js和相应依赖</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/adding-a-route-and-template">添加第一个路由与模板</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/modeling-data">建立模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/using-fixtures">使用静态数据</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/displaying-model-data">显示模型数据</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/displaying-a-models-completeness">显示模型的完成状态</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/creating-a-new-model">创建新的模型实例</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/marking-a-model-as-complete-incomplete">标记模型为完成或未完成</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/displaying-the-number-of-incomplete-todos">显示未完成待办事项的数量</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/toggle-todo-editing-state">切换显示和编辑状态</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/accepting-edits">接受修改</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/deleting-todos">删除模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/adding-child-routes">添加子路由</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/show-only-incomplete-todos">显示未完成待办事项</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/show-only-complete-todos">显示已完成待办事项</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/show-all-todos-again">显示所有待办事项</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/display-a-button-to-remove-completed-todos">添加移除所有已完成待办事项的按钮</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/show-when-all-todos-are-complete">提示所有待办事项已完成</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/toggle-all-todos">切换已完成和未完成待办事项</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/getting-started/using-other-adapters">更换FixtureAdapter</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/getting-ember">获取Ember</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/getting-ember">获取Ember</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/concepts/core-concepts">概念</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/concepts/core-concepts">核心概念</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/concepts/naming-conventions">命名惯例</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/object-model/classes-and-instances">对象模型</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/object-model/classes-and-instances">类与实例</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/computed-properties">计算属性</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/computed-properties-and-aggregate-data">计算属性和带@each的集合数据</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/observers">观察器</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/bindings">绑定</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/reopening-classes-and-instances">重新打开类和实例</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/what-do-i-use-when">绑定，观察器，计算属性：如何选择？</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/application">应用</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/application">介绍</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/templates/the-application-template">模板</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/templates/the-application-template">应用模板</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/handlebars-basics">Handlebars基础</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/conditionals">条件表达式</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/displaying-a-list-of-items">显示项目列表</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/changing-scope">切换作用域</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/binding-element-attributes">绑定元素属性</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/binding-element-class-names">绑定元素类名称</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/links">链接</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/actions">操作</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/input-helpers">输入助手</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/development-helpers">开发助手</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/rendering-with-helpers">用助手来渲染</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/writing-helpers">编写助手方法</a>
            </li>
          </ol></li>
          <li class="level-1 selected">
            <a href="/bilingual_guides/routing">路由</a>
            <ol class='selected'>
        
            <li class="level-3">
              <a href="/bilingual_guides/routing">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/defining-your-routes">定义路由</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/generated-objects">生成的对象</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/specifying-a-routes-model">指定路由的模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/setting-up-a-controller">设置控制器</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/rendering-a-template">渲染模板</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/redirection">重定向</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/specifying-the-location-api">指定地址API</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/query-params">查询参数</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/asynchronous-routing">异步路由</a>
            </li>
          
            <li class="level-3 sub-selected">
              <a href="/bilingual_guides/routing/loading-and-error-substates">加载中/错误子状态</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/preventing-and-retrying-transitions">阻止和重试过渡</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/components">组件</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/components">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/components/defining-a-component">定义组件</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/components/passing-properties-to-a-component">传递属性</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/components/wrapping-content-in-a-component">包裹内容</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/components/customizing-a-components-element">自定义组件元素</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/components/handling-user-interaction-with-actions">使用Action处理用户交互</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/components/sending-actions-from-components-to-your-application">从组件发送操作给应用</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/controllers">控制器</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/controllers">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/controllers/representing-a-single-model-with-objectcontroller">代表单一模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/controllers/representing-multiple-models-with-arraycontroller">代表多模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/controllers/dependencies-between-controllers">管理控制器间的依赖</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/models">模型</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/models">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/defining-models">定义模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/creating-and-deleting-records">创建和删除记录</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/pushing-records-into-the-store">将记录推入仓库</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/persisting-records">持久化记录</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/finding-records">查询记录</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/working-with-records">使用记录</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/the-fixture-adapter">使用Fixture</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/connecting-to-an-http-server">连接HTTP服务器</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/handling-metadata">处理元数据</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/customizing-adapters">自定义适配器</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/frequently-asked-questions">常见问题</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/views">视图</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/views">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/defining-a-view">定义视图</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/handling-events">处理事件</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/inserting-views-in-templates">在模板中插入视图</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/adding-layouts-to-views">为视图添加布局</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/customizing-a-views-element">自定义视图元素</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/built-in-views">内置视图</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/manually-managing-view-hierarchy">手动管理视图层级</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/enumerables">枚举</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/enumerables">介绍</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/testing">测试</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/testing">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/integration">集成测试</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/test-helpers">测试助手</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/testing-user-interaction">测试用户交互</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/unit">单元测试</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/unit-testing-basics">单元测试基础</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/testing-components">测试组件</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/testing-controllers">测试控制器</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/testing-routes">测试路由</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/testing-models">测试模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/testing/test-runners">自动化测试</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/configuring-ember/disabling-prototype-extensions">配置Ember.js</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/configuring-ember/disabling-prototype-extensions">禁用基本类型扩展</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/configuring-ember/embedding-applications">嵌入式应用</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/configuring-ember/feature-flags">特性标识</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/cookbook">Cookbook</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/cookbook">简介</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/cookbook/user_interface_and_interaction">用户界面与交互</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/cookbook/event_handling_and_data_binding">事件处理和数据绑定</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/cookbook/helpers_and_components">助手与组件</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/cookbook/working_with_objects">使用对象</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/understanding-ember/the-view-layer">理解Ember.js</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/understanding-ember/the-view-layer">视图层</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/understanding-ember/managing-asynchrony">管理异步</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/understanding-ember/keeping-templates-up-to-date">模板自动更新</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/understanding-ember/debugging">调试</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/understanding-ember/run-loop">运行循环</a>
            </li>
          </ol></li></ol>
  
          <div id="back-to-top"><a id="back-top-top" href="#">&#11014; 返回顶部</a></div>
        </div>
      
      <div id="content" class="has-sidebar">
          
  

  <div class="chapter">
    
        <h1>加载中/错误子状态 
          <a href="https://github.com/emberjs-cn/www.emberjs.cn/tree/master/source/guides/routing/loading-and-error-substates.md" target="_blank" class="edit-page">
            编辑页面</a>
        </h1>
      
    <p>In addition to the techniques described in the
<a href="http://emberjs.com/guides/routing/asynchronous-routing/">Asynchronous Routing Guide</a>,
the Ember Router provides powerful yet overridable
conventions for customizing asynchronous transitions
between routes by making use of <code>error</code> and <code>loading</code>
substates.</p>

<p>除了<a href="/guides/routing/asynchronous-routing/">异步路由指南</a>中描述的技术外，Ember路由还提供了通过使用<code>error</code>和<code>loading</code>子状态，来实现自定义路由间的异步过渡。</p>
<h2 class='anchorable-toc' id='toc_code-loading-code-substates'><code>loading</code> substates</h2><h2 class='anchorable-toc' id='toc_code-loading-code'><code>loading</code>子状态</h2>
<p>Consider the following:</p>

<p>考虑下面的情形：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.Router.map(<span class="keyword">function</span>() {
  <span class="local-variable">this</span>.resource(<span class="string"><span class="delimiter">'</span><span class="content">articles</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>() { <span class="comment">// -&gt; ArticlesRoute</span>
    <span class="local-variable">this</span>.route(<span class="string"><span class="delimiter">'</span><span class="content">overview</span><span class="delimiter">'</span></span>);              <span class="comment">// -&gt; ArticlesOverviewRoute</span>
  });
});
</pre></td>
</tr></table>
</div></div>
<p>If you navigate to <code>articles/overview</code>, and in <code>ArticlesRoute#model</code>, 
you return an AJAX query promise to load all of
the articles that takes a long time to complete.
During this time, your UI isn&#39;t really giving you any feedback as to
what&#39;s happening; if you&#39;re entering this route after a full page
refresh, your UI will be entirely blank, as you have not actually
finished fully entering any route and haven&#39;t yet displayed any
templates; if you&#39;re navigating to <code>articles/overview</code> from another
route, you&#39;ll continue to see the templates from the previous route
until the articles finish loading, and then, boom, suddenly all the
templates for <code>articles/overview</code> load. </p>

<p>如果导航到<code>articles/overview</code>，并且在<code>ArticlesRoute#model</code>中，返回了一个AJAX查询承诺，来加载需要花费较长时间才能完成加载的文章集合。在这其间，UI并不会有任何关于在做什么的实际性反馈；如果通过页面刷新进入到该页面，UI将会一直是空的，因为这时还没有完成进入路由，也没有显示任何模板；如果是从其他的路由进入<code>articles/overview</code>，那么会一直停留在之前路由渲染的模板，直到所有文章加载完成，这个时候<code>articles/overview</code>的所有模板才会被渲染，才可见。</p>

<p>So, how can we provide some visual feedback during the transition?</p>

<p>那么，在这个过渡的过程中该如何添加一些反馈信息呢？</p>
<h3 class='anchorable-toc' id='toc_the-code-loading-code-event'>The <code>loading</code> event</h3><h3 class='anchorable-toc' id='toc_code-loading-code'><code>loading</code>事件</h3>
<p>Before going into detail about loading substates, it&#39;s important
to understand the behavior of the <code>loading</code> event.</p>

<p>在深入讨论加载中子状态之前，理解<code>loading</code>事件的行为非常重要。</p>

<p>The Ember Router allows you to return promises from the various
<code>beforeModel</code>/<code>model</code>/<code>afterModel</code> hooks in the course of a transition
(described <a href="http://emberjs.com/guides/routing/asynchronous-routing/">here</a>).
These promises pause the transition until they fulfill, at which point
the transition will resume. If you return a promise from
one of these hooks, and it doesn&#39;t immediately resolve, a <code>loading</code>
event will be fired on that route and bubble upward to
<code>ApplicationRoute</code>. For example:</p>

<p>Ember路由允许通过<code>beforeModel</code>/<code>model</code>/<code>afterModel</code>各种钩子在一个过渡的过程中返回承诺（<a href="/guides/routing/asynchronous-routing">详细介绍</a>）。这些承诺在其被履行前会将过渡暂停。如果在其中一个钩子中返回了承诺，并且这个承诺没有理解解决，那么<code>loading</code>事件就会在该路由被触发，并且一直向上冒泡到<code>ApplicationRoute</code>。例如：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
19
<strong>20</strong>
</pre></td>
  <td class="code"><pre>App.Router.map(<span class="keyword">function</span>() {
  <span class="local-variable">this</span>.resource(<span class="string"><span class="delimiter">'</span><span class="content">foo</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>() { <span class="comment">// -&gt; FooRoute</span>
    <span class="local-variable">this</span>.route(<span class="string"><span class="delimiter">'</span><span class="content">slowModel</span><span class="delimiter">'</span></span>);        <span class="comment">// -&gt; FooSlowModelRoute</span>
  });
});

App.FooSlowModelRoute = Ember.Route.extend({
  <span class="function">model</span>: <span class="keyword">function</span>() {
    <span class="keyword">return</span> somePromiseThatTakesAWhileToResolve();
  },
  <span class="key">actions</span>: {
    <span class="function">loading</span>: <span class="keyword">function</span>(transition, originRoute) {
      <span class="comment">// displayLoadingSpinner();</span>

      <span class="comment">// Return true to bubble this event to `FooRoute`</span>
      <span class="comment">// or `ApplicationRoute`.</span>
      <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
  }
});
</pre></td>
</tr></table>
</div></div>
<p>If <code>FooRoute#model</code> had returned the slow promise, the <code>loading</code>
event would have fired on <code>FooRoute</code> (and not <code>FooSlowModelRoute</code>).</p>

<p>如果<code>FooSlowModelRoute</code>返回了一个较慢的承诺，那么<code>loading</code>事件就会在<code>FooRoute</code>上被触发（而不是<code>FooSlowModelRoute</code>上）。</p>
<h3 class='anchorable-toc' id='toc_the-default-implementation-of-the-code-loading-code-event'>The default implementation of the <code>loading</code> event</h3><h3 class='anchorable-toc' id='toc_code-loading-code'><code>loading</code>事件的缺省实现</h3>
<p>So already, you have a hook to allow you to configure loading
behavior in a hierarchical manner. But in addition to this, Ember
provides a default implementation of the <code>loading</code> handler that implements
the following loading substate behavior we&#39;ve been alluding to.</p>

<p>之前已经介绍了可以使用一种层次化的结构来配置<code>loading</code>行为。此外，Ember还提供了一种实现了如下所示的缺省的<code>loading</code>处理器。</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>App.Router.map(<span class="keyword">function</span>() {
  <span class="local-variable">this</span>.resource(<span class="string"><span class="delimiter">'</span><span class="content">foo</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>() {       <span class="comment">// -&gt; FooRoute</span>
    <span class="local-variable">this</span>.resource(<span class="string"><span class="delimiter">'</span><span class="content">foo.bar</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>() { <span class="comment">// -&gt; FooBarRoute</span>
      <span class="local-variable">this</span>.route(<span class="string"><span class="delimiter">'</span><span class="content">baz</span><span class="delimiter">'</span></span>);                  <span class="comment">// -&gt; FooBarBazRoute</span>
    });
  });
});
</pre></td>
</tr></table>
</div></div>
<p>If a route with the path <code>foo.bar.baz</code> returns a promise that doesn&#39;t immediately
resolve, Ember will try to find a <code>loading</code> route in the hierarchy 
above <code>foo.bar.baz</code> that it can transition into, starting with
<code>foo.bar.baz</code>&#39;s sibling:</p>

<p>如果<code>foo.bar.baz</code>路由返回了一个不会立即履行的承诺，Ember会在<code>foo.bar.baz</code>的层次结构中查找可以过渡的<code>loading</code>路由，查找路径为：</p>

<ol>
<li><code>foo.bar.loading</code></li>
<li><code>foo.loading</code></li>
<li><code>loading</code></li>
</ol>

<p>Ember will find a loading route at the above location if either a) a 
Route subclass has been defined for such a route, e.g.</p>

<p>Ember会在上述的<code>loading</code>路由地址找一个路由，a) 该路由可能是如下所示定义的一个路由的子类：</p>

<ol>
<li><code>App.FooBarLoadingRoute</code></li>
<li><code>App.FooLoadingRoute</code></li>
<li><code>App.LoadingRoute</code></li>
</ol>

<p>or b) a properly-named loading template has been found, e.g.</p>

<p>b) 又或者是一个按照一定规则进行命名的<code>loading</code>模板：</p>

<ol>
<li><code>foo/bar/loading</code></li>
<li><code>foo/loading</code></li>
<li><code>loading</code></li>
</ol>

<p>During a slow asynchronous transition, Ember will transition into the
first loading sub-state/route that it finds, if one exists. The
intermediate transition into the loading substate happens immediately 
(synchronously), the URL won&#39;t be updated, and, unlike other transitions
that happen while another asynchronous transition is active, the
currently active async transition won&#39;t be aborted.</p>

<p>在一个较慢的异步过渡过程中，如果存在<code>loading</code>子状态/路由，Ember会先过渡到第一个找到的。这个到<code>loading</code>子状态的中间状态的过渡会立即发生（同步的），URL也不会发生改变。与其他在当另一个异步过渡活动时发生的过渡不同，该情况下的活动异步过渡不会被取消。</p>

<p>After transitioning into a loading substate, the corresponding template
for that substate, if present, will be rendered into the main outlet of
the parent route, e.g. <code>foo.bar.loading</code>&#39;s template would render into 
<code>foo.bar</code>&#39;s outlet. (This isn&#39;t particular to loading routes; all
routes behave this way by default.)</p>

<p>当进入一个<code>loading</code>子状态过渡后，对应该子状态的模板如果存在的话，会被渲染到父路由的主插口（outlet），例如<code>foo.bar.loading</code>模板会被渲染到<code>foo.bar</code>的插口中。（<code>loading</code>路由并不是特例，所有路由都是按照这种方式工作的。）</p>

<p>Once the main async transition into <code>foo.bar.baz</code> completes, the loading
substate will be exited, its template torn down, <code>foo.bar.baz</code> will be
entered, and its templates rendered.</p>

<p>当<code>foo.bar.baz</code>主异步过渡完成时，会退出<code>loading</code>子状态，渲染的模板也会被移除，并进入<code>foo.bar.baz</code>，渲染其模板。</p>
<h3 class='anchorable-toc' id='toc_eager-vs-lazy-async-transitions'>Eager vs. Lazy Async Transitions</h3><h3 class='anchorable-toc' id='toc_vs'>渴望型 VS 延迟型异步过渡</h3>
<p>Loading substates are optional, but if you provide one,
you are essentially telling Ember that you
want this async transition to be &quot;eager&quot;; in the absence of destination
route loading substates, the router will &quot;lazily&quot; remain on the pre-transition route
while all of the destination routes&#39; promises resolve, and only fully
transition to the destination route (and renders its templates, etc.)
once the transition is complete. But once you provide a destination
route loading substate, you are opting into an &quot;eager&quot; transition, which
is to say that, unlike the &quot;lazy&quot; default, you will eagerly exit the
source routes (and tear down their templates, etc) in order to
transition into this substate. URLs always update immediately unless the
transition was aborted or redirected within the same run loop.</p>

<p><code>loading</code>子状态都是可选的，如果提供了<code>loading</code>子状态，那么就表示强调了希望异步过渡为“渴望型”的。在缺少目标路由的<code>loading</code>子状态时，路由将依然停留在之前的过渡路由，知道所有目标路由的承诺得到履行，知会在过渡完全完成是一次性过渡到目标路由（渲染模板等）。但是如果提供了一个目标路由的<code>loading</code>子状态，那么就选择了“渴望型”过渡，这就表明与默认的“延迟型”不同，会首先退出当前路由（清除其模板等），并过渡到<code>loading</code>子状态。除非过渡被取消或者在同一运行循环中被重定向，否则URL都会理解更新。</p>

<p>This has implications on error handling, i.e. when a transition into
another route fails, a lazy transition will (by default) just remain on the
previous route, whereas an eager transition will have already left the
pre-transition route to enter a loading substate.</p>

<p>这里也暗含了一个错误处理，例如，当过渡到一个路由失败时，延迟过渡（默认）会依然停留在原路由，而一个渴望过渡早就离开了之前的状态路由进入到<code>loading</code>子状态中了。</p>
<h2 class='anchorable-toc' id='toc_code-error-code-substates'><code>error</code> substates</h2><h2 class='anchorable-toc' id='toc_code-error-code'><code>error</code>子状态</h2>
<p>Ember provides an analogous approach to <code>loading</code> events/substates in
the case of errors encountered during a transition.</p>

<p>Ember为过渡提供了一种与<code>loading</code>事件/子状态类似的错误处理方法。</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.Router.map(<span class="keyword">function</span>() {
  <span class="local-variable">this</span>.resource(<span class="string"><span class="delimiter">'</span><span class="content">articles</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>() { <span class="comment">// -&gt; ArticlesRoute</span>
    <span class="local-variable">this</span>.route(<span class="string"><span class="delimiter">'</span><span class="content">overview</span><span class="delimiter">'</span></span>);              <span class="comment">// -&gt; ArticlesOverviewRoute</span>
  });
});
</pre></td>
</tr></table>
</div></div>
<p>If <code>ArticlesOverviewRoute#model</code> returns a promise that rejects (because, for
instance, the server returned an error, or the user isn&#39;t logged in,
etc.), an <code>error</code> event will fire on <code>ArticlesOverviewRoute</code> and bubble upward.
This <code>error</code> event can be handled and used to display an error message,
redirect to a login page, etc., but similar to how the default <code>loading</code>
event handlers are implemented, the default <code>error</code> handlers
will look for an appropriate error substate to
enter, if one can be found.</p>

<p>如果<code>ArticlesOverviewRoute</code>返回一个被拒绝的承诺（可能因为服务器端返回一个错误，又或者时用户没有登录等等），一个<code>error</code>事件将在<code>ArticlesOverviewRoute</code>被触发，并向上冒泡。可以使用这个<code>error</code>事件来处理并显示一个错误消息，例如重定向到登录页面等。与<code>loading</code>事件处理器实现类似，缺省的<code>error</code>事件处理器也会进入一个子状态来完成处理。</p>

<p>For instance, an error thrown or rejecting promise returned from
<code>ArticlesOverviewRoute#model</code> (or <code>beforeModel</code> or <code>afterModel</code>) 
will look for:</p>

<p>例如，在<code>ArticlesOverviewRoute#model</code>（或<code>beforeModel</code>、<code>afterModel</code>）中抛出了一个异常或者返回了一个被拒绝的承诺，那么会按照以下方式进行查找错误处理：</p>

<ol>
<li>Either <code>ArticlesErrorRoute</code> or <code>articles/error</code> template</li>
<li><p>Either <code>ErrorRoute</code> or <code>error</code> template</p></li>
<li><p><code>ArticlesErrorRoute</code>路由或者<code>articles/error</code>模板</p></li>
<li><p><code>ErrorRoute</code>路由或者<code>error</code>模板</p></li>
</ol>

<p>If one of the above is found, the router will immediately transition into
that substate (without updating the URL). The &quot;reason&quot; for the error 
(i.e. the exception thrown or the promise reject value) will be passed
to that error state as its <code>model</code>.</p>

<p>如果之上任意一个被找到，路由将立即过渡到该子状态（不更新URL），错误的“原因”（例如抛出的异常或拒绝的承诺）会作为<code>model</code>传递给<code>error</code>子状态。</p>

<p>If no viable error substates can be found, an error message will be
logged.</p>

<p>如果没有找到可以访问的<code>error</code>子状态，那么一条错误消息会在控制台中输出。</p>

<p>The only way in which <code>loading</code>/<code>error</code> substate resolution differs is
that <code>error</code> events will continue to bubble above a transition&#39;s pivot
route.</p>

<p><code>loading</code>/<code>error</code>子状态处理的唯一区别是，<code>error</code>从过渡的中心路由开始向上冒泡。</p>
<h3 class='anchorable-toc' id='toc_code-error-code-substates-with-dynamic-segments'><code>error</code> substates with dynamic segments</h3><h3 class='anchorable-toc' id='toc_code-error-code'>带动态段的<code>error</code>子状态</h3>
<p>Routes with dynamic segments are often mapped to a mental model of &quot;two
separate levels.&quot; Take for example:</p>

<p>带动态段的路由通常映射到一个模型的两个不同的层面。例如：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre>App.Router.map(<span class="keyword">function</span>() {
  <span class="local-variable">this</span>.resource(<span class="string"><span class="delimiter">'</span><span class="content">foo</span><span class="delimiter">'</span></span>, {<span class="key">path</span>: <span class="string"><span class="delimiter">'</span><span class="content">/foo/:id</span><span class="delimiter">'</span></span>}, <span class="keyword">function</span>() {
    <span class="local-variable">this</span>.route(<span class="string"><span class="delimiter">'</span><span class="content">baz</span><span class="delimiter">'</span></span>);
  });
});

App.FooRoute = Ember.Route.extend({
  <span class="function">model</span>: <span class="keyword">function</span>(params) {
    <span class="keyword">return</span> <span class="keyword">new</span> Ember.RSVP.Promise(<span class="keyword">function</span>(resolve, reject) {
       reject(<span class="string"><span class="delimiter">&quot;</span><span class="content">Error</span><span class="delimiter">&quot;</span></span>);
    });
  }
});
</pre></td>
</tr></table>
</div></div>
<p>In the URL hierarchy you would visit <code>/foo/12</code> which would result in rendering
the <code>foo</code> template into the <code>application</code> template&#39;s <code>outlet</code>. In the event of
an error while attempting to load the <code>foo</code> route you would also render the
top-level <code>error</code> template into the <code>application</code> template&#39;s <code>outlet</code>. This is
intentionally parallel behavior as the <code>foo</code> route is never successfully
entered. In order to create a <code>foo</code> scope for errors and render <code>foo/error</code>
into <code>foo</code>&#39;s <code>outlet</code> you would need to split the dynamic segment:</p>

<p>在URL层次中，访问<code>/foo/12</code>将会导致将<code>foo</code>模板渲染到<code>application</code>模板的<code>outlet</code>处。当尝试加载一个<code>foo</code>路由发生一个错误事件，会将顶层的<code>error</code>模板渲染到<code>application</code>模板的<code>outlet</code>。这感觉就好像<code>foo</code>路由就从未正确进入过一般。为了创建一个<code>foo</code>范围的错误信息，并渲染<code>foo/error</code>到<code>foo</code>的<code>outlet</code>中，那么需要将动态段分离：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>App.Router.map(<span class="keyword">function</span>() {
  <span class="local-variable">this</span>.resource(<span class="string"><span class="delimiter">'</span><span class="content">foo</span><span class="delimiter">'</span></span>, {<span class="key">path</span>: <span class="string"><span class="delimiter">'</span><span class="content">/foo</span><span class="delimiter">'</span></span>}, <span class="keyword">function</span>() {
    <span class="local-variable">this</span>.resource(<span class="string"><span class="delimiter">'</span><span class="content">elem</span><span class="delimiter">'</span></span>, {<span class="key">path</span>: <span class="string"><span class="delimiter">'</span><span class="content">:id</span><span class="delimiter">'</span></span>}, <span class="keyword">function</span>() {
      <span class="local-variable">this</span>.route(<span class="string"><span class="delimiter">'</span><span class="content">baz</span><span class="delimiter">'</span></span>);
    });
  });
});
</pre></td>
</tr></table>
</div></div>
<p><a href="http://emberjs.jsbin.com/ucanam/4279">Example JSBin</a></p>
<h2 class='anchorable-toc' id='toc_legacy-code-loadingroute-code'>Legacy <code>LoadingRoute</code></h2><h2 class='anchorable-toc' id='toc_code-loadingroute-code'>遗留的<code>LoadingRoute</code></h2>
<p>Previous versions of Ember (somewhat inadvertently) allowed you to define a global <code>LoadingRoute</code>
which would be activated whenever a slow promise was encountered during
a transition and exited upon completion of the transition. Because the
<code>loading</code> template rendered as a top-level view and not within an
outlet, it could be used for little more than displaying a loading
spinner during slow transitions. Loading events/substates give you far
more control, but if you&#39;d like to emulate something similar to the legacy
<code>LoadingRoute</code> behavior, you could do as follows:</p>

<p>之前的Ember版本（有些不慎）支持通过定义一个全局的<code>LoadingRoute</code>，该路由将在过渡遇到一个较慢的承诺或者完全退出一个过渡时被激活。因为<code>loading</code>模板作为顶层的视图来渲染，并没有放入到一个插口中，那么在这里处理可以显示一个加载中的指示器外几乎不能做其他的事情。与此相比较，<code>loading</code>事件/子状态提供了更强的控制力，如果希望模拟与遗留的<code>LoadingRoute</code>类似的行为，可以按照如下的例子来实现：</p>
<div class="highlight js "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre>App.LoadingView = Ember.View.extend({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">global-loading</span><span class="delimiter">'</span></span>,
  <span class="key">elementId</span>: <span class="string"><span class="delimiter">'</span><span class="content">global-loading</span><span class="delimiter">'</span></span>
});

App.ApplicationRoute = Ember.Route.extend({
  <span class="key">actions</span>: {
    <span class="function">loading</span>: <span class="keyword">function</span>() {
      <span class="keyword">var</span> view = <span class="local-variable">this</span>.container.lookup(<span class="string"><span class="delimiter">'</span><span class="content">view:loading</span><span class="delimiter">'</span></span>).append();
      <span class="local-variable">this</span>.router.one(<span class="string"><span class="delimiter">'</span><span class="content">didTransition</span><span class="delimiter">'</span></span>, view, <span class="string"><span class="delimiter">'</span><span class="content">destroy</span><span class="delimiter">'</span></span>);
    }
  }
});
</pre></td>
</tr></table>
</div></div>
<p><a href="http://emberjs.jsbin.com/ucanam/3307">Example JSBin</a></p>

<p>This will, like the legacy <code>LoadingRoute</code>, append a top-level view when the
router goes into a loading state, and tear down the view once the
transition finishes.</p>

<p><a href="http://emberjs.jsbin.com/ucanam/3307">JSBin示例</a></p>

<p>上例实现了一个与<code>LoadingRoute</code>类型的行为，当路由进入一个<code>loading</code>状态时，在顶层添加了一个视图，并在完成过渡时删除加入的视图。</p>

    
      <footer>
        
          <a class="previous-guide" href="/bilingual_guides/routing/asynchronous-routing">
            ← 异步路由
          </a>
         
        <a class="next-guide" href="/bilingual_guides/routing/preventing-and-retrying-transitions">
          阻止和重试过渡 →
        </a>
      
      </footer>
      
  </div>

      </div>
    </div>

    <div id="footer">
      <div id="footer-wrapper">
        <div class="info">&copy; 2014 Emberjs.CN <br/>Design by <a href="http://www.heropixel.com">HeroPixel</a></div>
        <div class="statement"><b>声明：</b>本站的文章可以随意在网上转载，但必须注明原文出处！</div>
        <div class="links">
          <a href="http://weibo.com/embercn"><img src="/images/weibo.png"/></a>
          <a href="http://emberjs.cn/blog/feed.xml"><img src="/images/feed.png"/></a>
        </div>
      </div>
    </div>

<!--[if lt IE 9]>
    <script type="text/javascript" src="/javascripts/common-old-ie.js"></script>
<![endif]-->
<!--[if gte IE 9]><!-->
    <script type="text/javascript" src="/javascripts/common-modern.js"></script>
<!--<![endif]-->

    
    <script type="text/javascript" src="/javascripts/guides.js"></script>
  

    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl = '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-38578402-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">
      var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
      document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F0b0fcec01b06cc76e274f7b21f4766c4' type='text/javascript'%3E%3C/script%3E"));

      $(function() {
        $('a[href="http://tongji.baidu.com/hm-web/welcome/ico?s=0b0fcec01b06cc76e274f7b21f4766c4"]').hide();
      });
    </script>

  </body>
</html>
